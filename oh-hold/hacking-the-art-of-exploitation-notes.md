# Note draft

## PLT & GOT

*  So, since this exploit technique has been known for so long, surely someone has done something about it, right? Well, it turns out yes, there’s been a [mitigation since 2004](https://www.sourceware.org/ml/binutils/2004-01/msg00070.html). Enter relocations read-only, or **RELRO**. It in fact has two levels of protection: partial and full RELRO.
  * Partial RELRO \(enabled with `-Wl,-z,relro`\):
    * Maps the `.got` section as read-only \(but _not_ `.got.plt`\)
    * Rearranges sections to reduce the likelihood of global variables overflowing into control structures.
  * Full RELRO \(enabled with `-Wl,-z,relro,-z,now`\):
    * Does the steps of Partial RELRO, plus:
    * Causes the linker to resolve all symbols at link time \(before starting execution\) and then remove write permissions from `.got`.
    * `.got.plt` is merged into `.got` with full RELRO, so you won’t see this section name.



* \(ELF\) I’ll start by saying if you’re on Windows you’ll be using the PE/COFF file format. Most of the principles explained here conceptually port over to the PE/COFF format.
  * The process image is created by loading and interpreting the segments. When building an executable file that uses dynamic linking, the link editor adds a program header element of type PT\_INTERP to an executable file, telling the system to invoke the dynamic linker as the program interpreter. The dynamic linker creates the process image for a program. At link time, the program or library is built by merging together sections with similar attributes into segments. Typically, all the executable and read-only data sections are combined into a single text segment, while the data and BSS are combined into the data segment. These segments are normally called load segments, because they need to be loaded in memory at process creation. Other sections such as symbol information and debugging sections are merged into other, non-load segments.
  * Creating the process image entails the following activities :
    * Adding the executable file’s memory segments to the process image
    * Adding shared object memory segments to the process image
    * Performing relocations for the executable file and its shared objects
    * Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker
    * Transferring control to the program, making it look as if the program had received control directly form exec\(BA\_OS\)



* Shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file’s program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case.



* The GOT is a table of addresses which resides in the data section. If some instruction in code wants to refer to a variable it must normally use an absolute memory address. Instead of referring to the absolute memory address, it refers to the GOT, whose location is known. The relative location of the GOT from the instruction in question is constant.
* Now you might be thinking, “Great, but I still have to resolve all those addresses within the GOT so what’s the point?” There are two things using the GOT gets us.
  1. We must relocate every reference in the code section. If everything references in the GOT we only must update the GOT once. This is much more efficient.
  2. The data section is both writable and not shared between processes. Performing relocations in this section causes no harm whereas in the code section relocations disallow sharing, which defeats the process of a shared library.
* The PLT is part of the executable text section, containing an entry for each external function the shared library calls. Each PLT entry is a short chunk of executable code. Instead of calling the function directly, the code calls an entry in the PLT, which then calls the actual function. Each entry in the PLT also has a corresponding entry in the GOT which contains the actual offset to the function, but only after the dynamic loader has resolved it.
* The PLT uses what is called lazy resolution. It won’t actually resolve the address of a function until it absolutely has to. This makes it so effort is only put into resolving those functions actually used. The process works in the following manner:
  1. A function func is called and the compiler translates this to a call to func@plt.
  2. The program jumps to the PLT. The PLT points to the GOT. If the function hasn’t been previously called, the GOT points back into the PLT to a resolver routine, otherwise it points to the function itself.



* Note that shared libraries have many names - shared libraries, shared objects, dynamic shared objects \(DSOs\), dynamically linked libraries \(DLLs - if you're coming from a Windows background\).
*   If we examine the ELF header of some random executable, we'll see an _Entry point address_:
  *  This is placed by the linker to tell the OS where to start executing the executable's code [\[1\]](https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/#id14) ...... we'll see the first instructions of the executable's .text segment there.
  *  What this means is that the linker, when linking the executable, can fully resolve all _internal_ symbol references \(to functions and data\) to fixed and final locations
  * Unlike executables, when shared libraries are being built, the linker can't assume a known load address for their code. The reason for this is simple. Each program can use any number of shared libraries, and there's simply no way to know in advance where any given shared library will be loaded in the process's virtual memory.
  *  In Linux, the _dynamic loader_  .... One of its tasks is to load shared libraries from disk into memory, when the running executable requests them. When a shared library is loaded into memory, it is then adjusted for its newly determined load location.
  * There are two main approaches to solve this problem in Linux ELF shared libraries:
    1. Load-time relocation
    2. Position independent code \(PIC\)
* **load-time relocation :**
  * The linker places some provisional pre-defined value \(0x0 in this case\) into the instruction stream, and then creates a special relocation entry pointing to this place.
  * ```text
    Offset     Info    Type            Sym.Value  Sym. Name
    00000470  00000401 R_386_32          0000200C   myglob
    ```
  * The rel.dyn section of ELF is reserved for dynamic \(load-time\) relocations, to be consumed by the dynamic loader
  * relocation type R\_386\_32 means: take the value at the offset specified in the entry, add the address of the symbol to it, and place it back into the offset.
    * we now see it says: add the address of myglob to the operand of that mov instruction. In other words it tells the dynamic loader - once you perform actual address assignment, put the real address of myglob into 0x470, thus replacing the operand of mov by the correct symbol value
  * Note also the "Sym. value" column in the relocation section, which contains 0x200C for myglob. This is the offset of myglob in the virtual memory image of the shared library \(which, recall, the linker assumes is just loaded at 0x0\). This value can also be examined by looking at the symbol table of the library, for example with nm
  *  Curiously, due to the [address space layout randomization feature](http://en.wikipedia.org/wiki/Address_space_layout_randomization) which is enabled in Linux, relocation is relatively difficult to follow, because every time I run the executable, the libmlreloc.so shared library gets placed in a different virtual memory address
  * readelf
  * R\_386\_PC32
    * It means the following: take the value at the offset specified in the entry, add the address of the symbol to it, subtract the address of the offset itself, and place it back into the word at the offset.
    *  What does this do? Basically, it's a _relative_ relocation, taking its location into account and thus suitable for arguments of instructions with relative addressing
    * Take the value at the offset specified in the entry \(0xfffffffc\), add the address of the symbol to it \(0x0012e49c\), subtract the address of the offset itself \(0x0012e4b4\), and place it back into the word at the offset.
    * go back to the code of the shared library, add static to the declaration of ml\_util\_func.
      * the relocation is gone! Examine the disassembly of ml\_func - there's now a correct offset placed as the argument of call - no relocation required.
      * When tying global symbol references to their actual definitions, the dynamic loader has some rules about the order in which shared libraries are searched. The user can also influence this order by setting the LD\_PRELOAD environment variable
      *  n short, however, when ml\_util\_func is global, it may be overridden in the executable or another shared library, so when linking our shared library, the linker can't just assume the offset is known and hard-code it. It makes all references to global symbols relocatable in order to allow the dynamic loader to decide how to resolve them. This is why declaring the function static makes a difference - since it's no longer global or exported, the linker can hard-code its offset in the code
      * These days, position independent code \(PIC\) is a more popular approach, and some modern systems \(such as x86-64\) no longer support load-time relocation.



* the section is the .got.plt section, which is a specific section dedicated to hold a table of pointers, as an interface for the application to access relocated dynamically linked procedures addresses.





* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

