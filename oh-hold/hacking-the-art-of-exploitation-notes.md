# Note draft

## PLT & GOT

*  So, since this exploit technique has been known for so long, surely someone has done something about it, right? Well, it turns out yes, there’s been a [mitigation since 2004](https://www.sourceware.org/ml/binutils/2004-01/msg00070.html). Enter relocations read-only, or **RELRO**. It in fact has two levels of protection: partial and full RELRO.
  * Partial RELRO \(enabled with `-Wl,-z,relro`\):
    * Maps the `.got` section as read-only \(but _not_ `.got.plt`\)
    * Rearranges sections to reduce the likelihood of global variables overflowing into control structures.
  * Full RELRO \(enabled with `-Wl,-z,relro,-z,now`\):
    * Does the steps of Partial RELRO, plus:
    * Causes the linker to resolve all symbols at link time \(before starting execution\) and then remove write permissions from `.got`.
    * `.got.plt` is merged into `.got` with full RELRO, so you won’t see this section name.



* \(ELF\) I’ll start by saying if you’re on Windows you’ll be using the PE/COFF file format. Most of the principles explained here conceptually port over to the PE/COFF format.
  * The process image is created by loading and interpreting the segments. When building an executable file that uses dynamic linking, the link editor adds a program header element of type PT\_INTERP to an executable file, telling the system to invoke the dynamic linker as the program interpreter. The dynamic linker creates the process image for a program. At link time, the program or library is built by merging together sections with similar attributes into segments. Typically, all the executable and read-only data sections are combined into a single text segment, while the data and BSS are combined into the data segment. These segments are normally called load segments, because they need to be loaded in memory at process creation. Other sections such as symbol information and debugging sections are merged into other, non-load segments.
  * Creating the process image entails the following activities :
    * Adding the executable file’s memory segments to the process image
    * Adding shared object memory segments to the process image
    * Performing relocations for the executable file and its shared objects
    * Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker
    * Transferring control to the program, making it look as if the program had received control directly form exec\(BA\_OS\)



* Shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file’s program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case.



* The GOT is a table of addresses which resides in the data section. If some instruction in code wants to refer to a variable it must normally use an absolute memory address. Instead of referring to the absolute memory address, it refers to the GOT, whose location is known. The relative location of the GOT from the instruction in question is constant.
* Now you might be thinking, “Great, but I still have to resolve all those addresses within the GOT so what’s the point?” There are two things using the GOT gets us.
  1. We must relocate every reference in the code section. If everything references in the GOT we only must update the GOT once. This is much more efficient.
  2. The data section is both writable and not shared between processes. Performing relocations in this section causes no harm whereas in the code section relocations disallow sharing, which defeats the process of a shared library.
* The PLT is part of the executable text section, containing an entry for each external function the shared library calls. Each PLT entry is a short chunk of executable code. Instead of calling the function directly, the code calls an entry in the PLT, which then calls the actual function. Each entry in the PLT also has a corresponding entry in the GOT which contains the actual offset to the function, but only after the dynamic loader has resolved it.
* The PLT uses what is called lazy resolution. It won’t actually resolve the address of a function until it absolutely has to. This makes it so effort is only put into resolving those functions actually used. The process works in the following manner:
  1. A function func is called and the compiler translates this to a call to func@plt.
  2. The program jumps to the PLT. The PLT points to the GOT. If the function hasn’t been previously called, the GOT points back into the PLT to a resolver routine, otherwise it points to the function itself.

## Process

* What is a process? A process is a program in execution.
* What is a program? A program is a file containing the information of a process and how to build it during run time. When you start execution of the program, it is loaded into RAM and starts executing.
* An ELF programme consists of an ELF header, a program header table, a number of sections and an optional section header table. The header contains all the information the kernel needs to create a process image \(i.e. load the programme into memory and allocate resources to prepare it for execution\).
* Programme code on a multitasking operating system must be re-entrant. This means it can be shared by multiple processes. To be re-entrant the code must not modify itself at any time and the data must be stored separately from the instruction text \(such that each independent process can maintain its own data space\).
* When a programme is loaded as a process it is allocated a section of virtual memory which forms its useable address space

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

