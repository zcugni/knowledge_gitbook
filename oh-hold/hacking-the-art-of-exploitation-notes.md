# Note draft

## PIC

* it's possible to make the text section of the shared library truly _position independent_, in the sense that it can be easily mapped into different memory addresses without needing to change one bit.
*  One of the key insights on which PIC relies is the offset between the text and data sections, known to the linker _at link-time_. When the linker combines several object files together, it collects their sections \(for example, all text sections get unified into a single large text section\). Therefore, the linker knows both about the sizes of the sections and about their relative locations.
* For example, the text section may be immediately followed by the data section
  * so the offset from any instruction in .text section to the beginning of the .data section is : .text\_size - instruction\_offset
* The above is only useful if we can actually put the relative offset to work. But data references \(i.e. in the mov instruction\) on x86 require absolute addresses
  * If we have a relative address and need an absolute address, what's missing is the value of the instruction pointer
  * There's no instruction to obtain the value of the instruction pointer on x86, but we can use a simple trick to get it. Here's some assembly pseudo-code that demonstrates it:

    ```text
        call TMPLABEL
    TMPLABEL:
        pop ebx
    ```
* suppose some instruction in the code section wants to refer to a variable. Instead of referring to it directly by absolute address \(which would require a relocation\), it refers to an entry in the GOT. Since the GOT is in a known place in the data section, this reference is relative and known to the linker. The GOT entry, in turn, will contain the absolute address of the variable:
* A relocation in the data section is much less problematic than one in the code section, for two reasons
  * 1. Relocations in the code section are required _per variable reference_, while in the GOT we only need to relocate once _per variable_. There are likely much more references to variables than variables, so this is more efficient.
    2. The data section is writable and not shared between processes anyway, so adding relocations to it does no harm. Moving relocations from the code section, however, allows to make it read-only and share it between processes.
*  But what about function calls? Theoretically, the exact same approach could work for function calls as well. Instead of call actually containing the address of the function to call, let it contain the address of a known GOT entry, and fill in that entry during loading.

  But this is _not_ how function calls work in PIC. What actually happens is a bit more complicated.

* **The lazy binding optimization**
  *  When a shared library refers to some function, the real address of that function is not known until load time. Resolving this address is called _binding_, and it's something the dynamic loader does when it loads the shared library into the process's memory space. This binding process is non-trivial, since the loader has to actually _look up_ the function symbol in special tables
  * So, resolving each function takes time
  * . Moreover, most of these resolutions are done in vain, because in a typical run of a program only a fraction of functions actually get called
  * The PLT is part of the executable text section, consisting of a set of entries \(one for each external function the shared library calls\).
  *  Each PLT entry is a short chunk of executable code. Instead of calling the function directly, the code calls an entry in the PLT, which then takes care to call the actual function. This arrangement is sometimes called a "[trampoline](http://en.wikipedia.org/wiki/Trampoline_%28computing%29)". 
  * Each PLT entry also has a corresponding entry in the GOT which contains the actual offset to the function, but only when the dynamic loader resolves it.
  * The PLT consists of a special first entry, followed by a bunch of identically structured entries, one for each function needing resolution
  *  Each PLT entry but the first consists of these parts:
    * A jump to a location which is specified in a corresponding GOT entry \(pointer\)
    * Preparation of arguments for a "resolver" routine
    * Call to the resolver routine, which resides in the first entry of the PLT
  *  The first PLT entry is a call to a resolver routine, which is located in the dynamic loader itself [\[6\]](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/#id14). This routine resolves the actual address of the function
  * What happens when func is called for the first time is this:
    * PLT\[n\] is called and jumps to the address pointed to in GOT\[n\].
    * This address points into PLT\[n\] itself, to the preparation of arguments for the resolver.
    * The resolver is then called.
    * The resolver performs resolution of the actual address of func, places its actual address into GOT\[n\] and calls func.
  * Note that GOT\[n\] now points to the actual func [\[7\]](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/#id15) instead of back into the PLT. So, when func is called again:
    * PLT\[n\] is called and jumps to the address pointed to in GOT\[n\].
    * GOT\[n\] points to func, so this just transfers control to func.
  * The resolver is simply a chunk of low-level code in the loader that does symbol resolution. The arguments prepared for it in each PLT entry, along with a suitable relocation entry, help it know about the symbol that needs resolution and about the GOT entry to update.
  * see cost
  * 

## PLT & GOT

*  So, since this exploit technique has been known for so long, surely someone has done something about it, right? Well, it turns out yes, there’s been a [mitigation since 2004](https://www.sourceware.org/ml/binutils/2004-01/msg00070.html). Enter relocations read-only, or **RELRO**. It in fact has two levels of protection: partial and full RELRO.
  * Partial RELRO \(enabled with `-Wl,-z,relro`\):
    * Maps the `.got` section as read-only \(but _not_ `.got.plt`\)
    * Rearranges sections to reduce the likelihood of global variables overflowing into control structures.
  * Full RELRO \(enabled with `-Wl,-z,relro,-z,now`\):
    * Does the steps of Partial RELRO, plus:
    * Causes the linker to resolve all symbols at link time \(before starting execution\) and then remove write permissions from `.got`.
    * `.got.plt` is merged into `.got` with full RELRO, so you won’t see this section name.



* \(ELF\) I’ll start by saying if you’re on Windows you’ll be using the PE/COFF file format. Most of the principles explained here conceptually port over to the PE/COFF format.
  * The process image is created by loading and interpreting the segments. When building an executable file that uses dynamic linking, the link editor adds a program header element of type PT\_INTERP to an executable file, telling the system to invoke the dynamic linker as the program interpreter. The dynamic linker creates the process image for a program. At link time, the program or library is built by merging together sections with similar attributes into segments. Typically, all the executable and read-only data sections are combined into a single text segment, while the data and BSS are combined into the data segment. These segments are normally called load segments, because they need to be loaded in memory at process creation. Other sections such as symbol information and debugging sections are merged into other, non-load segments.
  * Creating the process image entails the following activities :
    * Adding the executable file’s memory segments to the process image
    * Adding shared object memory segments to the process image
    * Performing relocations for the executable file and its shared objects
    * Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker
    * Transferring control to the program, making it look as if the program had received control directly form exec\(BA\_OS\)



* Shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file’s program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case.



* The GOT is a table of addresses which resides in the data section. If some instruction in code wants to refer to a variable it must normally use an absolute memory address. Instead of referring to the absolute memory address, it refers to the GOT, whose location is known. The relative location of the GOT from the instruction in question is constant.
* Now you might be thinking, “Great, but I still have to resolve all those addresses within the GOT so what’s the point?” There are two things using the GOT gets us.
  1. We must relocate every reference in the code section. If everything references in the GOT we only must update the GOT once. This is much more efficient.
  2. The data section is both writable and not shared between processes. Performing relocations in this section causes no harm whereas in the code section relocations disallow sharing, which defeats the process of a shared library.
* The PLT is part of the executable text section, containing an entry for each external function the shared library calls. Each PLT entry is a short chunk of executable code. Instead of calling the function directly, the code calls an entry in the PLT, which then calls the actual function. Each entry in the PLT also has a corresponding entry in the GOT which contains the actual offset to the function, but only after the dynamic loader has resolved it.
* The PLT uses what is called lazy resolution. It won’t actually resolve the address of a function until it absolutely has to. This makes it so effort is only put into resolving those functions actually used. The process works in the following manner:
  1. A function func is called and the compiler translates this to a call to func@plt.
  2. The program jumps to the PLT. The PLT points to the GOT. If the function hasn’t been previously called, the GOT points back into the PLT to a resolver routine, otherwise it points to the function itself.

## Process

* What is a process? A process is a program in execution.
* What is a program? A program is a file containing the information of a process and how to build it during run time. When you start execution of the program, it is loaded into RAM and starts executing.
* An ELF programme consists of an ELF header, a program header table, a number of sections and an optional section header table. The header contains all the information the kernel needs to create a process image \(i.e. load the programme into memory and allocate resources to prepare it for execution\).
* Programme code on a multitasking operating system must be re-entrant. This means it can be shared by multiple processes. To be re-entrant the code must not modify itself at any time and the data must be stored separately from the instruction text \(such that each independent process can maintain its own data space\).
* When a programme is loaded as a process it is allocated a section of virtual memory which forms its useable address space

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

