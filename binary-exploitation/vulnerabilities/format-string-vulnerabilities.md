# Format String Vulnerabilities

## Generalities

* Whenever a format function is used \(like `printf`\), we can abuse it **if we control the format part**
* For each specifier, `printf` will read the memory at the current stack pointer and interpret it according to the specifier
* It has a variable number of arguments, so it blindly follows the specifiers
  * If we provide more than there's parameters, it will read the stack
* All the following explanation is focused on C's `printf`, but similar things should be possible in other languages
* Useful format specifiers are :
  * `%x` Read the stack in hexadecimal / Move stack pointer
  * `%s` Read any memory addresses / Crash the program
  * `%n` Write to memory

## %x

* For the 2 following specifiers, you'll want the stack pointer at a certain place \(generally inside your format string, which is also on the stack\)
* However, it's rarely directly there, so you'll need to move it
* `%x` "consume" the stack
* The exact distance to traverse depends on the situation, so trial and error is needed
  * Alignment might also make this harder
* However, since `%x` can also be used to simply read the stack in hexadecimal, you can locate your input easily

## %s

* Since it'll try to interpret what it is given as a memory address, it might get a non-existent or a protected one, and crash
* Since we control the format string, and it's pushed to the stack, we can insert an address in it and then use %s to read it : `printf(“\xef\xbe\xad\xde %x %x %x %s”);`
  * Will read the address at 0xdeadbeef

## %n

* It will **write** the number of characters written so far into the memory address pointed by it's variable
* If we replace `%s` with `%n` in the above example, it'll write at 0xdeadbeef instead of read it
* Use **padding** to get `%n` to the right number :
  * Define padding with `%<number><specifier>` 
  * Prepend with `0` to pad with 0 instead of spaces
  * For example `%064u` will pad the number with 0 to 64 chars
* **Short write** lets you write memory 2 bytes at a time `%hn`
* **Direct parameter access** let you access any of the printf arguments
  * Syntax : `%<nb_arg>$<specifier>`
  * Example : `printf("This is the 7th arg : %7$d", 1, 2, 3, 4, 5, 6, 7, 8, 9")`
  * Combination with field with parameters :  `%<nb_args>$[0]<min_width><format_specifier>`
    * Example : `%4$05d`

#### Consecutive writes

* Sometimes the number you need to write \(like a memory address\) is simply to big to just pad it
* Instead, do ****consecutive rights to shifted memory addresses, each time writing 1 byte
  * Each memory addresses is shifted by 1 byte
  * Start by writing the **right-most byte** to the first address
  * You need to write chars until you have a number whom **least significant byte** is what you want
    * This means that if you want to write `0x4b` but `%n` is already superior to that, you can write `0x14b`
    * The rest will be overwritten anyway
  * With this technique however, the 3 bytes following the target address will also be overwritten
  * Example :

```text
Memory                     94 95 96 97
First write to 0x08049794  AA 00 00 00
Second write to 0x08049795    BB 00 00 00
Third write to 0x08049796        4B 10 00 00
Fourth write to 0x08049797          DD 00 00 00
Result                     AA BB 4B DD
```

* Process :
  * Find the offset between the stack pointer and the format string \(by printing a lot of `%x` with a recognizable input\)
  * In your payload, write the 4 addresses \(or 2 with short writes\) you want to write to
  * Then for each :
    * Use a specifier with padding as filler to get `%n` to what you need
    * Use `%n` with the correct direct access parameter number

## Direct access parameters

* This is a syntax that lets you directly access parameters and it can be combined with our format specifiers, making it way easier to exploit
* Check [this page](https://zcugni.gitbook.io/notes/languages/c#printf) for syntax

## Final example

* The first 2 lines are the address in which to write \(shifted by 2 byte each time\)
* Next comes the combination of `%x` and `%n`
  * `%x` Uses field width to get %n to the right number
  * `%n` Uses direct parameter access to easily get the right address and `h` to write the address 2 by instead of 1 by 1

```python
$ python -c 'print 
                "\x94\x97\x04\x08" +
                "\x96\x97\x04\x08" + 
                "%98x" + "%4$hn" + 
                "%258x" + "%6$hn" +
```

## Sources

* Hacking : The Art of Exploitation by John Erickson
* [A pdf](http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf)
* [medium](https://medium.com/swlh/binary-exploitation-format-string-vulnerabilities-70edd501c5be)

