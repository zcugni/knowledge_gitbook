# Shellcode

## Introduction

* Crafted malicious strings that lets you run command or other instructions
* The goal is usually to redirect the flow of the program to your shellcode
* Shellcode are **position-independent code**, they need to be self-contained and work wherever they're inserted
* Pre-written assembly shellcode are available at [shell-storm](http://shell-storm.org/shellcode/)

## Generals tips

* **Connection** via shellcode :
  * Prefer a **connect-back** shellcode to a port-binding one since firewalls usually block incoming connections to strange ports but not outgoing ones
  * To avoid generating a new TCP connection, re-use existing sockets when you can
* If you need to write a string in the shellcode that would be **sanitized**, add a number to every characters to pass sanitization, and sub it back afterwards in your shellcode
* Don't forget to reset **privileges** dropped with `setreuid()` and the likes
* The same way you can increase the range of targeted addresses with a nop slide, you can increase the range of addresses of a targeted string with spaces at the beginning of it 

## Tips for assembly shellcode

### Retrieve a string

If you need to reference a string in your shellcode, it needs to be at an address you can easily retrieve/deduce. There's 2 ways :

* **Environment variables** \(also useful if the buffer is too small for your shellcode\)
* Retrieved from the **stack** :
  * Whenever a `call` is executed, the following address is put on the stack
  * You can put the string just after the call so that it's his address that's pushed
  * Then make a `jmp` instruction instead of a call, and `pop` the value from the stack into a register

### Null bytes

* Shellcode are usually copied via `strcpy()` and the likes, so **they mustn't contain `\0`** \(since they'll stop the copy at the null byte\)
* It possible to access only some part of the extended \(32 bits\) registers, which makes it less probable to have `\0` padding :
  * `eax` The whole register
  * `ax` The lowest \(rightmost\) 16-bits
  * `ah` The high bits of `ax`
  * `al` The low bits of `ax`
* `call` work on the whole register, but `jmp` **can be short**
  * Because of 2's complement, a call to a **negative value** will have all of it's 0 flipped
    * Similarly, instead of adding a small value to a number, you can instead sub a very large one from it
  * The **solution** then is to make a `jmp short` to a `call` that will use a negative value

### Nop Slide

* The stack won't be exactly the same on different environment \(even just on different terminals\), because executable names, env var, etc are pushed to the stack
* This makes guessing the exact address you want to redirect the program to difficult
* The 1-byte **nop** assembly instruction stands for "No operation", it's a filler instruction
  * When reading it, the program won't do anything and just advance to the next instruction
* To  **increase the possible range of address** that will redirect to your shell code, you can create a **nop slide**
  * This means writing a lot of nop instruction before your shellcode
  * You can then redirect the program anywhere in the slide and the program will "ride" it until your shellcode

### Sanitization

* Use registers and arithmetic operations to craft values that would be **sanitized**
  * For example, you can move another value to a register, add or subtract from it so that it equals what you want, and push the register instead of directly the value
* To **zero out** a value :
  * Prefer **`xor`** to `sub`, since it doesn't modify flags
* A nop slide is a good indicator of exploitation, so IDS & co will search for them
  * Instead, you can use other 1 byte instruction like `inc` or `dec`
* Some instruction have a corresponding **ascii** character, which have less chance of being sanitized

| Instruction | Hex | ASCII character |
| :--- | :--- | :--- |
| `inc eax` | `0x40` | `@` |
| `inc ebx` | `0x41` | `A` |
| `inc edx` | `0x42` | `B` |
| `dec eax` | `0x48` | `H` |
| `dec ebx` | `0x4B` | `K` |
| `dec ecx` | `0x49` | `I` |
| `dec edx` | `0x4A` | `J` |
| `and eax,<value>` | `0x25<...>` | % |

* `and eax,..` Can be used to zero out eax with a printable instruction, you just need a value that is its bitwise inverse
* **Polymorphic** shellcode are shellcode that modify themselves
  * For example, if only printable characters can be use, create a printable shellcode that will create in memory a more complex shellcode using the sanitized chars
    * This is the **loader** code
  * The general technique is to : 
    * First set `esp` back behind the loader code \(in higher memory addresses\)
    * Then build the shellcode from end to start by pushing values onto the stack

### Minimization

* If `eax` is 0, use `cdq` instead of `xor` to zero out `edx`
  * It convert a doubleword to a quadword
  * It takes it's source from `eax` and store the result between `eax` & `edx`
  * So if `eax` is 0, `edx` will be too
  * `cdq` use one less byte than `xor`
* Instead of zeroing out a register and then putting a value into it, `push` then `pop` a value to the stack
  * A small value will be extended to the whole length of the register, zeroing it out

## Source

* _Hacking : The Art of Exploitation_ by John Erickson
* [Liveoverflow's](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) binary exploitation series

