# Vulnerabilities

## Buffer Overflows

* Buffer overflows let you overwrite memory by overflowing a buffer in which your input is written
  * This is only possible when the length of your input isn't checked
* The most common buffer overflows are stack related, they work by overflowing the local variable to write over the **return address**, enabling us to decide which instructions will be read next
  * If you're not sure of the distance between your input and the return address, just fill it with the crafted return address. At least one instance will overwrite what you want \(given that the stack is aligned\)
* When overflowing memory allocated on the heap, errors in the heap headers will be detected during  `free()`, and the program will stop
  * However, if you could do what you want before the free, it's not important

{% hint style="info" %}
* Check heap unlinking
* Since the write of the book, there's probably more mitigation, research that
{% endhint %}

## Shellcode

* Crafted malicious strings that lets you run command or other instructions
* The goal is usually to redirect the flow of the program to your shellcode
* Shellcode are **position-independent code**, they need to be self-contained and work wherever they're inserted
* Pre-written assembly shellcode are available at [shell-storm](http://shell-storm.org/shellcode/)

### Generals tips

* **Connection** via shellcode :
  * Prefer a **connect-back** shellcode to a port-binding one since firewalls usually block incoming connections to strange ports but not outgoing ones
  * To avoid generating a new TCP connection, re-use existing sockets when you can
* If you need to write a string in the shellcode that would be **sanitized**, add a number to every characters to pass it, and sub it back afterwards in your shellcode
* Don't forget to reset **privileges** dropped with `setreuid()` and the likes
* The same way you can increase the range of targeted addresses with a nop sled, you can increase the range of addresses of a targeted string with spaces at the beginning of it 

### Tips for assembly shellcode

* If you need to reference a string in your shellcode, it needs to be at an address you can easily retrieve/deduce. There's 2 ways :
  * **Environment variables** \(also useful if the buffer is too small for your shellcode\)
  * Retrieved from the **stack** :
    * Whenever a `call` is executed, the following address is put on the stack
    * You can put the string just after the call so that it's his address that's pushed
    * Then make a `jmp` instruction instead of a call, and `pop` the value from the stack into a register
* Shellcode are usually copied via strcpy\(\) and the likes, so **they mustn't contain `\0`** \(since they'll stop the copy at the null byte\)
  * Some extended \(32 bits\) registers can be accessed in part :
    * `eax` The whole register
    * `ax` The lowest \(rightmost\) 16-bits
    * `ah` The high bits of `ax`
    * `al` The low bits of `ax`
  * `call` Work on the whole register, so small value will often be padded with `\0`
    * **`jmp` Can be short**, so there's less risk of that happening
    * Because of 2's complement, a call to a **negative value** will have all of it's 0 flipped
      * Similarly, instead of adding a small value to a number, you can instead sub a very large one from it
    * The solution then is to make a `jmp short` to `call` that will use a negative value
* Use registers and arithmetic operations to craft values that would be **sanitized**
  * For example, you can move another value to a register, add or subtract from it so that it equals what you want, and push the register instead of directly the value
* To **zero out** a value :
  * Prefer **`xor`** to `sub`, since it doesn't modify flags
* A nop slide is a good indicator of exploitation, so IDS & co will search for them
  * Instead, you can use other 1 byte instruction like `inc` or `dec`
* Some instruction have a corresponding **ascii** character, which have less chance of being sanitized

| Instruction | Hex | ASCII character |
| :--- | :--- | :--- |
| `inc eax` | `0x40` | `@` |
| `inc ebx` | `0x41` | `A` |
| `inc edx` | `0x42` | `B` |
| `dec eax` | `0x48` | `H` |
| `dec ebx` | `0x4B` | `K` |
| `dec ecx` | `0x49` | `I` |
| `dec edx` | `0x4A` | `J` |
| `and eax,<value>` | `0x25<...>` | % |

* `and eax,..` Can be used to zero out eax with a printable instruction, you just need a value that is its bitwise inverse
* **Polymorphic** shellcode are shellcode that modify themselves
  * For example, if only printable characters can be use, create a printable shellcode that will create in memory a more complex shellcode using the sanitized chars
    * This is the **loader** code
  * The general technique is to : 
    * First set `esp` back behind the loader code \(in higher memory addresses\)
    * Then build the shellcode from end to start by pushing values onto the stack

### Minimization

* Here's some tricks if you need to minimize your shellcode
* If `eax` is 0, use `cdq` instead of `xor` to zero out `edx`
  * It convert a doubleword to a quadword
  * It takes it's source from `eax` and store the result between `eax` & `edx`
  * So if `eax` is 0, `edx` will be too
  * `cdq` use one less byte than `xor`
* Instead of zeroing out a register and then putting a value into it, `push` then `pop` a value to the stack
  * A small value will be extended to the whole length of the register, zeroing it out

## Nop Slide

* The stack won't be exactly the same on different environment \(even just on different terminals\), because executable names, env var, etc are pushed to the stack
* This makes guessing the exact address you want to redirect the program to difficult
* The 1-byte **nop** assembly instruction stands for "No operation", it's a filler instruction
  * When reading it, the program won't do anything and just advance to the next instruction
* To  **increase the possible range of address** that will redirect to your shell code, you can create a **nop slide**
  * This means writing a lot of nop instruction before your shellcode
  * You can then redirect the program anywhere in the slide and the program will "ride" it until your shellcode

## ret2libc & Return-oriented programming

* Some programs implement protection to prevent buffer overflow from being usable, like :
  * Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
  * Making the stack writable only, not executable
* To **bypass** that, there's different options :
  * **Change the return address to itself** \(so to the address of the ret call\)
    * It will pop itself from the stack and then \(since a ret call is made again\), set the `ip` to the next address on the stack \(which we control\)
  * **Return to a function within the libc** \(which is probably loaded for the program\) by crafting the stack as if a ret call was made. 
    * You'll need to write to the stack :
      * The address of the function you want to use
      * An address for this function to return to after it finishes
      * Its arguments \(if they're strings,  you'll need to store/find them in memory\)
    * The address of a function within the libc will be different for each sysntem, but will stay the same until it is recompiled
      * Create a simple dummy program and debug it to find the address
    * This principle is called **ret2libc**
* Both techniques can be chained multiple times

## Crafting inputs

### Python

* For simple exploits, you can craft your input using python and then send it to the vulnerable program
* Different ways to craft it :

```python
python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
python generate_input.py | /path/to/exe
(python generate_input.py; cat) | /path/to/exe
```

* The last one is needed for shellcode that returns a shell because they need an `stdin`, however, when your script finishes outputting the input, it will close the pipe
  * Using `cat` without parameters redirects `stdin` to `stdout`, keeping the pipe open
* Send the payload as a **parameter** instead of an input :

```bash
./exe $(python -c "print 'your_hex'")
./exe "`python -c "print 'your_hex'"`"
```

### C

* For more complicated exploits, where you need to find specific memory addresses, etc, it might be easier to create a C binary that will launch the command with specifics parameters, making it possible to use C functions
* Be careful, a setuid program using `system()` won't transfer the privileges because they'll be drop by `/bin/bash`, prefer functions like `execle()`
* This is a \(truncated\) example from _Hacking : The Art of Exploitation_ that shows the kind of C program you would use for a stack buffer overflow :

```c
#include ...

char shellcode[]= "\x31\xc0\x31....";

int main(int argc, char *argv[]) {
  unsigned int i, ret;
  char *env[2] = {shellcode, 0};
  char *buffer = (char *) malloc(160);
  
  // Since we use a custom environment with execle
  // We can deduce the address of the shellcode  
  ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen("./notesearch");
  
  // We write the wanted address multiple times
  // to be sure to overwrite the return address with it
  for(i=0; i < 160; i+=4)
    *((unsigned int *)(buffer+i)) = ret;
  
  // notesearch is the command to launch
  execle("./notesearch", "notesearch", buffer, 0, env);
  free(buffer);
}
```

## Bouncing of Linux gate

* Not possible since Linux 2.6.18
* `linux-gate.so.1` is a virtual dynamically shared object used by the kernel to speed up system call and therefor needed in every process 
  * It's loaded straight from the kernel and doesn't exist on disk
* Even with ASLR, it's **was** always present at the same address
* The goal was to find the address of an `jmp esp` within the object, in order to overwrite the return address with it
* When returning, `eip` point to our `jmp esp`, which returns us on our shellcode

## GOT 

* A good target for memory rewrite is the `.got`
* However, countermeasure exist : 
  * Partial RELRO : 
    * Makes the .got read only
    * Rearrange the sections to reduce the likelihood of dangerous overflows
  * Full RELRO does the same plus :
    * Forces the linker to resolve all symbols at link time \(before execution\) then remove write permission from .got
    * .got.plt is merged into.got

## ASLR

* Address Space Layout Randomization \(**ASLR**\) is a technique used against memory vulnerabilities
* As it names suggest, it randomize the offset of the different sections of memory, making it difficult to guess where the stack, libraries, etc are

## Sources

* _Hacking : The Art of Exploitation_ by John Erickson
* For buffer overflows :
  * [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
  * [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)

