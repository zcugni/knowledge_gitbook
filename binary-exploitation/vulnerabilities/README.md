# Vulnerabilities

## Buffer Overflows

* Buffer overflows let you overwrite memory by overflowing a buffer in which your input is written
  * This is only possible when the length of your input isn't checked
* Usually, they're used to redirect the program to some crafted [shellcode](https://zcugni.gitbook.io/notes/binary-exploitation/vulnerabilities/shellcode)
  * On the stack,  the goal is to overwrite the **return address**, making it possible to decide which instruction will be read next
    * If you're not sure of the distance between your input and the return address, just write multiple times the desired return address. At least one instance will overwrite what you want \(given that the stack is aligned\)
  * On the heap, the goal might be to corrupt heap metadata to abuse some functionalities  of `malloc()`or `free()` for example

## Bouncing of Linux gate

* Not possible since Linux 2.6.18
* `linux-gate.so.1` is a virtual dynamically shared object used by the kernel to speed up system call and is therefor needed in every process 
  * It's loaded straight from the kernel and doesn't exist on disk
* Even with ASLR \(see below\), it's **was** always present at the same address
* The goal is to overwrite the return address with the address of an `jmp esp` within the object
  * When returning, `eip` point to our `jmp esp`, which returns us on our shellcode

## Others

* The other vulnerabilities have the own pages :
  * [Format String vuln](https://zcugni.gitbook.io/notes/binary-exploitation/vulnerabilities/format-string-vulnerabilities)
  * [Shellcode](https://zcugni.gitbook.io/notes/binary-exploitation/vulnerabilities/shellcode)
  * [Malloc vuln](https://zcugni.gitbook.io/notes/binary-exploitation/vulnerabilities/malloc-vulnerabilities)
* Check also the protection bypass below

## Countermeasure

### GOT 

* A good target for memory rewrite is the [`.got`](https://zcugni.gitbook.io/notes/binary-exploitation/executable-creation/elf-file-linking#position-independent-code)\`\`
* However, countermeasure exist : 
  * Partial RELRO : 
    * Makes the `.got` read only
    * Rearrange the sections to reduce the likelihood of dangerous overflows
  * Full RELRO does the same plus :
    * Forces the linker to resolve all symbols at link time \(before execution\) then remove write permission from `.got`
    * `.got.plt` is merged into `.got`

### ASLR

* Address Space Layout Randomization \(**ASLR**\) is a technique used against memory vulnerabilities
* As it names suggest, it randomize the offset of the different sections of memory, making it difficult to guess where the stack, libraries, etc are

### Protection against stack buffer overflows

* Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
* Making the stack writable only, not executable

## Protection bypass

* To bypass stack buffer overflow protection, there's 2 options : 
  * Change the return address to itself
  * Return to the libc library \(ret2libc\)
* Both techniques can be chained multiple times
* In the first one, we set the return address to the one of the `ret` instruction
  * It will pop itself from the stack and then \(since a `ret` call is made again\), set the `eip` to the next address on the stack \(which we control\)

### Ret2libc

* The libc is probably loaded by the program so the goal is to return to one of its function by crafting the stack as if a ret call was made
* The address of a function within the libc will be different for each system, but will stay the same until it is recompiled
  * Create a simple dummy program and debug it to find the address of the function you want
* You'll need to write to the stack :
  * The address of the function you want to use
  * An address for this function to return to after it finishes
  * Its arguments \(if they're strings,  you'll need to store/find them in memory\)

## Crafting inputs

### Python

* For simple exploits, you can craft your input using python and then send it to the vulnerable program
* Different ways to craft it :

```python
python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
python generate_input.py | /path/to/exe
(python generate_input.py; cat) | /path/to/exe
```

* The last one is needed for shellcode that returns a shell because they need an `stdin`, however, when your script finishes outputting the input, it will close the pipe
  * Using `cat` without parameters redirects `stdin` to `stdout`, keeping the pipe open
* Send the payload as a **parameter** instead of an input :

```bash
./exe $(python -c "print 'your_hex'")
./exe "`python -c "print 'your_hex'"`"
```

### C

* For more complicated exploits, where you need to find specific memory addresses, etc, it might be easier to create a C binary that will launch the command with specifics parameters, making it possible to use C functions
* Be careful, a setuid program using `system()` won't transfer the privileges because they'll be drop by `/bin/bash`
  * Prefer functions like `execle()`
* This is a \(truncated\) example from _Hacking : The Art of Exploitation_ that shows the kind of C program you would use for a stack buffer overflow :

```c
#include ...

char shellcode[]= "\x31\xc0\x31....";

int main(int argc, char *argv[]) {
  unsigned int i, ret;
  char *env[2] = {shellcode, 0};
  char *buffer = (char *) malloc(160);
  
  // Since we use a custom environment with execle
  // We can deduce the address of the shellcode  
  ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen("./notesearch");
  
  // We write the wanted address multiple times
  // to be sure to overwrite the return address with it
  for(i=0; i < 160; i+=4)
    *((unsigned int *)(buffer+i)) = ret;
  
  // notesearch is the vulnerable command of this exca
  execle("./notesearch", "notesearch", buffer, 0, env);
  free(buffer);
}
```

## 

## Sources

* _Hacking : The Art of Exploitation_ by John Erickson
* For buffer overflows :
  * [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
  * [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)
* [Liveoverflow's](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) binary exploitation series

