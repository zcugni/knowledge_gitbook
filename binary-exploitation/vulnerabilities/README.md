# Vulnerabilities

## Buffer Overflows

* Buffer overflows let you overwrite memory by overflowing a buffer in which your input is written
  * This is only possible when the length of your input isn't checked
* On the stack, buffer overflows let you overwrite the **return address**, enabling you to decide which instructions will be read next
  * If you're not sure of the distance between your input and the return address, just fill it with the crafted return address. At least one instance will overwrite what you want \(given that the stack is aligned\)
* On the heap, they're often used to corrupt the heap metadata in order to abuse some mechanism of `malloc()`or `free()` for example
* Both are used to redirect the flow of the program to some crafted shellcode, detailed here

## ret2libc & Return-oriented programming

* Some programs implement protection to prevent buffer overflow from being usable, like :
  * Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
  * Making the stack writable only, not executable
* To **bypass** that, there's different options :
  * **Change the return address to itself** \(so to the address of the ret call\)
    * It will pop itself from the stack and then \(since a ret call is made again\), set the `ip` to the next address on the stack \(which we control\)
  * **Return to a function within the libc** \(which is probably loaded for the program\) by crafting the stack as if a ret call was made. 
    * You'll need to write to the stack :
      * The address of the function you want to use
      * An address for this function to return to after it finishes
      * Its arguments \(if they're strings,  you'll need to store/find them in memory\)
    * The address of a function within the libc will be different for each sysntem, but will stay the same until it is recompiled
      * Create a simple dummy program and debug it to find the address
    * This principle is called **ret2libc**
* Both techniques can be chained multiple times

## Bouncing of Linux gate

* Not possible since Linux 2.6.18
* `linux-gate.so.1` is a virtual dynamically shared object used by the kernel to speed up system call and therefor needed in every process 
  * It's loaded straight from the kernel and doesn't exist on disk
* Even with ASLR, it's **was** always present at the same address
* The goal was to find the address of an `jmp esp` within the object, in order to overwrite the return address with it
* When returning, `eip` point to our `jmp esp`, which returns us on our shellcode

## Crafting inputs

### Python

* For simple exploits, you can craft your input using python and then send it to the vulnerable program
* Different ways to craft it :

```python
python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
python generate_input.py | /path/to/exe
(python generate_input.py; cat) | /path/to/exe
```

* The last one is needed for shellcode that returns a shell because they need an `stdin`, however, when your script finishes outputting the input, it will close the pipe
  * Using `cat` without parameters redirects `stdin` to `stdout`, keeping the pipe open
* Send the payload as a **parameter** instead of an input :

```bash
./exe $(python -c "print 'your_hex'")
./exe "`python -c "print 'your_hex'"`"
```

### C

* For more complicated exploits, where you need to find specific memory addresses, etc, it might be easier to create a C binary that will launch the command with specifics parameters, making it possible to use C functions
* Be careful, a setuid program using `system()` won't transfer the privileges because they'll be drop by `/bin/bash`, prefer functions like `execle()`
* This is a \(truncated\) example from _Hacking : The Art of Exploitation_ that shows the kind of C program you would use for a stack buffer overflow :

```c
#include ...

char shellcode[]= "\x31\xc0\x31....";

int main(int argc, char *argv[]) {
  unsigned int i, ret;
  char *env[2] = {shellcode, 0};
  char *buffer = (char *) malloc(160);
  
  // Since we use a custom environment with execle
  // We can deduce the address of the shellcode  
  ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen("./notesearch");
  
  // We write the wanted address multiple times
  // to be sure to overwrite the return address with it
  for(i=0; i < 160; i+=4)
    *((unsigned int *)(buffer+i)) = ret;
  
  // notesearch is the command to launch
  execle("./notesearch", "notesearch", buffer, 0, env);
  free(buffer);
}
```

## Countermeasure

### GOT 

* A good target for memory rewrite is the [`.got`](https://zcugni.gitbook.io/notes/binary-exploitation/executable-creation/elf-file-linking#position-independent-code)\`\`
* However, countermeasure exist : 
  * Partial RELRO : 
    * Makes the .got read only
    * Rearrange the sections to reduce the likelihood of dangerous overflows
  * Full RELRO does the same plus :
    * Forces the linker to resolve all symbols at link time \(before execution\) then remove write permission from `.got`
    * `.got.plt` is merged into `.got`

### ASLR

* Address Space Layout Randomization \(**ASLR**\) is a technique used against memory vulnerabilities
* As it names suggest, it randomize the offset of the different sections of memory, making it difficult to guess where the stack, libraries, etc are

## Sources

* _Hacking : The Art of Exploitation_ by John Erickson
* For buffer overflows :
  * [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
  * [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)
* [Liveoverflow's](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) binary exploitation series

