# Vulnerabilities

## Buffer Overflows

* Buffer overflows let you overwrite memory by overflowing a buffer in which your input is written
  * This is only possible when the length of your input isn't checked
* The most common buffer overflows are stack related, they work by overflowing the local variable to write over the **return address**, enabling us to decide which instructions will be read next
  * If you're not sure of the distance between your input and the return address, just fill it with the crafted return address. At least one instance will overwrite what you want \(given that the stack is aligned\)
* When overflowing memory allocated on the heap, errors in the heap headers will be detected during  `free()`, and the program will stop
  * However, if you could do what you want before the free, it's not important

{% hint style="info" %}
* Check heap unlinking
* Since the write of the book, there's probably more mitigation, research that
{% endhint %}

## Shellcode

* Crafted malicious strings that lets you run command or other instructions
* The goal is usually to redirect the flow of the program to your shellcode
* Shellcode are **position-independent code**, they need to be self-contained and work wherever they're inserted
* Pre-written assembly shellcode are available at [shell-storm](http://shell-storm.org/shellcode/)
* _Port-binding shellcode_ will generally be prevented by firewalls since they usually block incoming connections to strange port
  * Prefer to it **connect-back shellcode** that initiates a TCP connection back to the attackerâ€™s IP

### Tips for assembly shellcode

* If you need to reference a string in your shellcode, it needs to be at an address you can easily retrieve/deduce. There's 2 ways :
  * **Environment variables** \(also useful if the buffer is too small for your shellcode\)
  * Retrieved from the **stack** :
    * Whenever a `call` is executed, the following address is put on the stack
    * You can put the string just after the call so that it's his address that's pushed
    * Then make a `jmp` instruction instead of a call, and `pop` the value from the stack into a register
* Shellcode are usually copied via strcpy\(\) and the likes, so **they mustn't contain `\0`** \(since they'll stop the copy at the null byte\)
  * Some extended \(32 bits\) registers can be accessed in part :
    * `eax` The whole register
    * `ax` The lowest \(rightmost\) 16-bits
    * `ah` The high bits of `ax`
    * `al` The low bits of `ax`
  * `call` Work on the whole register, so small value will often be padded with `\0`
    * **`jmp` Can be short**, so there's less risk of that happening
    * Because of 2's complement, a call to a **negative value** will have all of it's 0 flipped
    * The solution then is to make a `jmp short` to `call` that will use a negative value
* Use registers and arithmetic operations to craft values that would be **sanitized**
  * For example, you can move another value to a register, add or subtract from it so that it equals what you want, and push the register instead of directly the value
* To **zero out** a value :
  * Prefer **`xor`** to `sub`, since it doesn't modify flags
* Don't forget to reset privileges dropped with `setreuid()` and the likes

### Minimization

* Here's some tricks if you need to minimize your shellcode
* If `eax` is 0, use `cdq` instead of `xor` to zero out `edx`
  * It convert a doubleword to a quadword
  * It takes it's source from `eax` and store the result between `eax` & `edx`
  * So if `eax` is 0, `edx` will be too
  * `cdq` use one less byte than `xor`
* Instead of zeroing out a register and then putting a value into it, `push` then `pop` a value to the stack
  * A small value will be extended to the whole length of the register, zeroing it out

## Nop Slide

* The stack won't be exactly the same on different environment \(even just on different terminals\), because executable names, env var, etc are pushed to the stack
* This makes guessing the exact address you want to redirect the program to difficult
* The 1-byte **nop** assembly instruction stands for "No operation", it's a filler instruction
  * When reading it, the program won't do anything and just advance to the next instruction
* To  **increase the possible range of address** that will redirect to your shell code, you can create a **nop slide**
  * This means writing a lot of nop instruction before your shellcode
  * You can then redirect the program anywhere in the slide and the program will "ride" it until your shellcode

## Return oriented-programming / ret2libc

* Some programs implement protection to prevent buffer overflow from being usable, like :
  * Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
  * Making the stack writable only, not executable
* To **bypass** that, there's different options :
  * **Change the return address to itself** \(so to the address of the ret call\)
    * It will pop itself from the stack and then \(since a ret call is made again\), set the `ip` to the next address on the stack \(which we control\)
  * **Return to a function within the libc** \(which is probably loaded for the program\) by crafting the stack as if a ret call was made. You'll need to write to the stack :
    * The address of the function you want to use
    * An address for this function to return to after it finishes
    * Its arguments \(if they're strings, you'll need to [find in memory](https://zcugni.gitbook.io/notes/binary-exploitation/tools/gdb-gnu-debugger#find-string-in-memory) a place where the string is written and give its address\)
    * This principle is called **ret2libc**
* Both techniques can be chained multiple times

## Crafting inputs

### Python

* For simple exploits, you can craft your input using python and then send it to the vulnerable program
* Different ways to craft it :

```python
python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
python generate_input.py | /path/to/exe
(python generate_input.py; cat) | /path/to/exe
```

* The last one is needed for shellcode that returns a shell because they need an `stdin`, however, when your script finishes outputting the input, it will close the pipe
  * Using `cat` without parameters redirects `stdin` to `stdout`, keeping the pipe open
* Send the payload as a **parameter** instead of an input :

```bash
./exe $(python -c "print 'your_hex'")
./exe "`python -c "print 'your_hex'"`"
```

### C

* For more complicated exploits, where you need to find specific memory addresses, etc, it might be easier to create a C binary that will launch the command with specifics parameters, making it possible to use C functions
* Be careful, a setuid program using `system()` won't transfer the privileges because they'll be drop by `/bin/bash`, prefer functions like `execle()`
* This is a \(truncated\) example from _Hacking : The Art of Exploitation_ that shows the kind of C program you would use for a stack buffer overflow :

```c
#include ...

char shellcode[]= "\x31\xc0\x31....";

int main(int argc, char *argv[]) {
  unsigned int i, ret;
  char *env[2] = {shellcode, 0};
  char *buffer = (char *) malloc(160);
  
  // Since we use a custom environment with execle
  // We can deduce the address of the shellcode  
  ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen("./notesearch");
  
  // We write the wanted address multiple times
  // to be sure to overwrite the return address with it
  for(i=0; i < 160; i+=4)
    *((unsigned int *)(buffer+i)) = ret;
  
  // notesearch is the command to launch
  execle("./notesearch", "notesearch", buffer, 0, env);
  free(buffer);
}
```

## Tips & Tricks

* 
## Sources

* Hacking : The Art of Exploitation by John Erickson
* For buffer overflows :
  * [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
  * [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)

