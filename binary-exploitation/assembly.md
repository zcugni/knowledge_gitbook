# Assembly

## Disclaimer

I'm still knew to this field, so i might not always use the rights terms. It's also possible that i generalize concepts specific to the few architecture i studied and vice-versa.

## Generalities

* Assembly is the language closest to the machine
  * As such, each type of processor has a different set of instructions \(such as `mov`, jumps, etc\) with different opcodes \(hex number identifying an instruction\), etc
* **Disassembling** means transforming a binary back to assembly code
* This page will mostly speak about **IA-32 architecture using the x86 instruction set** \(i'm not entirely sure of the terminology\)

## AT&T vs Intel syntax

* On x86 architecture, there's 2 different possible syntax to write assembly

![](../.gitbook/assets/att-vs-intel.png)

* The list of differences is as follows :
  * Register reference  
    * AT & T  use `%` as a prefix  :`%esp`
    * Intel don't use any prefix : `esp`
  * Constant variable
    * AT & T use `$` as a prefix : `$10`, `$0x80485d0`
    * Intel don't use any prefix : `10`, `0x80485d0`
  * Offset
    * AT & T : `0x10(%esp)`
    * Intel : `[esp+0x10]`
  * Order of parameters
    * AT&T : `mov src,dest`
    * Intel : `mov dest,src`
  * Data size 
    * AT&T  use different suffix `movl ..`
    * Intel use different keywords words `mov DWORD PTR ...`

## Registers

* Access to memory takes time, so processors have some internal memory called **registers** that are faster to access
* Their number depends on the architecture
* In IA-32 architecture, there's :
  * Ten 32-bit registers
  * Six 16-bit registers
  * These are divided in categories :
    * General, subdivided in :
      * Data
      * Pointer
      * Index
    * Control
    * Segment
  * Even if other architectures have more or less registers, some concept still exist, like the stack or instruction pointers
* 32-bits register are called "extended ...", like **extended instruction pointer** `(eip)`
  * The lowest \(rightmost\) 16-bits part will be called the `ip`
  * For some registers, like `eax`, it can be further divided. The high part of `ax` is `ah` and the low part `al`

### **Data**

* 32-bit registers that can be divided in 16-bits or 8-bits parts if needed
* `eax` Primary accumulator, used in I/O & arithmetic
* `ebx` Base register, used in index addressing
* `ecx` Count Register, used in iterative operations
* `edx` Data register, used along `eax` for long values

### Pointer

* 32-bit registers \(but actually only the rightmost 16 bits is used if i understood correctly\)
* `eip` Store the offset address of the **next instruction** to read
  * Appended to  `cs` it gives the absolute address within the code segment
  * `eip` is sometime called `pc` for _Program Counter_
* `esp` Store the offset address of **the top of the stack**
  * Appended to `ss` it gives the absolute address within the stack segment
* `ebp` Used when calling other functions to keep track of the old `esp` value
  * It kinds of delimits the stack area \(aka **stack frame**\) of the new function with the previous one

### Index

* 32-bit registers that can be divided in 16-bits parts if needed
* Used for string operations
* `esi` Source index
* `edi` Destination index

### Control

* The control register contains flag bits that are set during arithmetic operations and then used in condition \(like jumps\)
* Possible flag \(in, to my opinion, most to less useful order\) :
  * **Zero Flag \(ZF\)** - Indicates if the result of an operation equal 0
    *  Also called the **Equal Flag** because it's used in compare instruction to see if two values are equal \(by subtracting them\)
  * **Interrupt Flag \(IF\)** - Enable \(with 1\) or disable \(with 0\) external interrupts, like from a keyboard
  * **Trap Flag \(TF\)** - Allows to single-step forward instruction for debugging
  * **Sign Flag \(SF\)** - Indicates the sign of the result of an operation \(1 if negative\)
  * **Parity Flag \(PF\)** - If the number of 1-bits in the result is even, it's set to 0, otherwise 1
  * **Carry Flag \(CF\)** - Contains either :
    * The carry of 0 or 1 from the high-order \(leftmost\) bit after an operation
    * The contents of the last bit of a shift or rotate operation
  * **Overflow Flag \(OF\)** - Indicates the overflow of the high-order \(leftmost\) bit after a signed operation 
  * **Direction Flag \(DF\)** - Determines direction when working with strings, 0 for left-to-right, 1 for right-to-left
  * **Auxiliary Carry Flag \(AF\)** - Contains the carry from bit 3 to 4 after an operation
* In the register, this is the position of the flags :

| 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| :--- | :--- | :--- | :--- | :--- | :--- | :---: | :--- | :--- | :--- | :--- | :--- |
| O | D | I | T | S | Z |  | A |  | P |  | C |

* I don't know what the rest of the bits are used for

### Segment

* Specific area are reserved for the data, the code & the stack
* Six 16 bits registers keep the starting address of these segment
* `cs` for the **code segment**
* `ss` for the **stack segment**
* `ds` for the **data segment**
* `es`, `fs` & `gs` provides additional segment

## Sources

* [http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html](http://web.mit.edu/rhel-doc/3/rhel-as-en-3/i386-syntax.html)

