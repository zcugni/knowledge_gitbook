# Stack layout in function

I'll detail the process of calling a new function and how it affects the stack and these three registers : `ip`,`sp`,`bp`.

However, there's some differences between 32-bit and 64-bit architecture \(64-bit stores some arguments in registers instead of the stack\). This details the process on 32-bit.

* Before the `call` instruction, push the **arguments** in reverse order \(the last one first\) to the stack
  * Doing it in reverse place the first argument at the top of the stack
* During the `call` function, the **return address** is pushed to the stack
* The new function does the following :
  * Push the current value of **bp** to the stack
  * Set **bp** to **sp**, so that it stores the address of the top of the stack at the beginning of the function
    * This makes it easier to access the arguments afterwards \(since **sp** will change during the course of the function\)
  * Push the **local variables** to the stack
* When returning the function :
  * Sets **sp** to **bp**, so that the stack returns to the state it had when the new function was set up
  * Pop **sp** \(aka the **old bp**\) to **bp**, so it retrieve it's old value from before the function call
  * Pop **sp** \(aka the **return address**\) to **ip**, so the program can continue where it left of before the function call

{% hint style="info" %}
Create schemas
{% endhint %}

## Sources

* [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
* [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)



