# Format String Vulnerabilities

## Generalities

* Whenever a format function is used \(like `printf`\), we can abuse it **if we control the format part**
* For each specifier, printf will read the memory at the current stack pointer and interpret it according to the specifier
* It has a variable number of arguments, so it blindly follows the specifiers
  * If we provide more than there's parameters, it will read the stack
* All the following explanation is focused on C's printf, but similar things should be possible in other languages
* Useful format specifiers are :
  * `%x` Read the stack in hexadecimal / Move stack pointer
  * `%s` Read any memory addresses / Crash the program
  * `%n` Write to memory

## %x

* For the two following specifiers, you'll want the stack pointer at a certain place \(generally inside your format string, which is also on the stack\)
* However, it's rarely directly there, so you'll need to move it. `%x` "consume" the stack.
* The exact distance to traverse depends on the situation, so trial and error is needed
  * Alignment might also make this harder
* However, since `%x` can also be used to simply read the stack in hexadecimal, you can locate your input easily

## %s

* Since it'll try to interpret what it is given as a memory address, it might get a non-existent or a protected one, and crash
* Since we control the format string, and it's pushed to the stack, we can insert an address in it and then use %s to read it : `printf(“\xef\xbe\xad\xde %x %x %x %s”);`
  * Will read the address at 0xdeadbeef

## %n

* It will write the number of characters written so far into the memory address pointed by it's variable
* If we replace `%s` with `%n` in the above example, it'll write at 0xdeadbeef instead of read it
* When you need to write a big number, like a memory address, instead of using a lot of filler chars to get %n to the right number, do **consecutive rights** to shifted memory addresses, each time writing 1 byte
  * However, with this technique, the 3 bytes after the target address will also be overwritten
  * If, for a following write, you need a lesser number that what %n would be, simply write an even bigger one with the least significant byte being what you want \(aka, write `0x1ab` instead of `0xab`\). The additional byte will be overwritten afterwards anyway
  * Example :

```text
Memory                     94 95 96 97
First write to 0x08049794  AA 00 00 00
Second write to 0x08049795    BB 00 00 00
Third write to 0x08049796        AB 10 00 00
Fourth write to 0x08049797          DD 00 00 00
Result                     AA BB AB DD
```

* Use **length modifiers** to write many chars with a few one \(for example `%64d` will pad the number with spaces to 64 chars\)
* Short write lets you write memory 2 bytes at a time `%hn`

## Direct access parameters

* This is a syntax that lets you directly access parameters and it can be combined with our format specifiers, making it way easier to exploit
* Check ... for syntax

## Final example

* The first 2 lines are the address in which to write \(shifted by 2 byte each time\)
* Next comes the combination of `%x` and `%n`
  * `%x` Uses field width to get %n to the right number
  * `%n` Uses direct parameter access to easily get the right address and `h` to write the address 2 by instead of 1 by 1

```python
$ python -c 'print 
                "\x94\x97\x04\x08" +
                "\x96\x97\x04\x08" + 
                "%98x" + "%4$hn" + 
                "%258x" + "%6$hn" +
```

