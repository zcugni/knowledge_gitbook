# ELF Files

## Generalities

* An elf file can be :
  * A relocatable object file
  * An executable
  * A core file
  * A shared object
* An ELF file is composed of :
  * An header
  * An optional program header \(for executable and shared object files\)
  * An optional section header \(for linking\)

## Header

The header is described as a C struct :

```c
#define EI_NIDENT 16

typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    ElfN_Addr     e_entry;
    ElfN_Off      e_phoff;
    ElfN_Off      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfN_Ehdr;
```

* `e_ident` An array specifying how to interpret the file, its bytes are divided as follows :
  * Each byte can be access through it's "name", for example `e_ident[EI_MAGO]`
  * The value 0 is often use for non-acceptable values, so i won't detail them
  * Bytes 0-1-2-3 \(`EI_MAG0`-`EI_MAG1`-`EI_MAG2`-`EI_MAG3`\) : Must be `0x7fELF`
  * Byte 4 \(`EI_CLASS`\) - Identifies the architecture, can be:
    * 1 for `ELFCLASS32`
    * 2 for `ELFCLASS64`
  * Byte 5 \(`EI_DATA`\) - Specify the encoding, can be :
    * 1 for `ELFDATA2LSB` : 2's complement, little-endian
    * 2 for `ELFDATA2MSB` : 2's complement, big-endian
  * Byte 6 \(`EI_VERSION`\) : ELF's specification version
  * Byte 7 \(`EI_OSABI`\) : Specify the targeted OS and Application Binary Interface \(ABI\), there's multiple so I won't list them
  * Byte 8 \(`EI_ABIVERSION`\) : Version of the specified ABI
  * Byte 9-14 \(`EI_PAD`\) : Reserved bytes set to 0
  * Byte 15 \(`EI_NIDENT`\) : The size of the array
* `e_type` The type of ELF file
  * 1 for `ET_REL` A relocatable file
  * 2 for `ET_EXEC` An executable file
  * 3 for `ET_DYN` A shared object
  * 4 for `ET_CORE` A core file
* `e_machine` Specifies the required architecture for an individual file, there's multiple so i won't list them
* `e_version` The version of the file
* `e_entry`The virtual address to which the system first transfers control, thus starting the process
  * 0 If no associated entry point
* `e_phoff`The program header table's offset in bytes, 0 if not present
* `e_shoff`The section header table's offset in bytes, 0 if not present
* `e_flags` __Holds processor-specific flags associated with the file
  * Flag names take the form `EF<machine_flag>`
  * Currently, no flags defined
* `e_ehsize` The ELF header's size in bytes
* `e_phentsize`The size in bytes of a program header, all entries are the same size
* `e_phnum`The number of program headers
  * If the number of entries is &gt;= 0xffff, it holds `0xffff` and the real number is in the `sh_info` of the first header in the section header table
* `e_shentsize` The size in bytes of a section header, all entries are the same size
* `e_shnum` The number of section header
  * If the number of entries is &gt;= 0xffff, it holds `0xffff` and the real number is in the `sh_info` of the first header in the section header table
* `e_shstrndx`The index of the section header that is associated with the section name string table
  * "If the index of the section name string table section is &gt;= 0xff00, it holds `0xffff` and the real index of the section name string table section is held in the `sh_link`of the initial entry in section header table"
  * "index in Section Header Table Denoting Section dedicated to Hold Section names."
  * 

### Program header table

* The program header table is an array of structures, each describing a segment \(or other information the system needs to prepare the program for execution\)
* An object file segment contains one or more sections
* There's 2 structures depending on the architecture :

```c
typedef struct {
   uint32_t   p_type;
   Elf32_Off  p_offset;
   Elf32_Addr p_vaddr;
   Elf32_Addr p_paddr;
   uint32_t   p_filesz;
   uint32_t   p_memsz;
   uint32_t   p_flags;
   uint32_t   p_align;
} Elf32_Phdr;

typedef struct {
   uint32_t   p_type;
   uint32_t   p_flags;
   Elf64_Off  p_offset;
   Elf64_Addr p_vaddr;
   Elf64_Addr p_paddr;
   uint64_t   p_filesz;
   uint64_t   p_memsz;
   uint64_t   p_align;
} Elf64_Phdr;
```

* The difference is the position of the `p_flags`
* `p_type` Some available types : 
  * `PT_NULL` **Unassigned** segment \(usually 1st entry of the program header table\)
  * `PT_LOAD` **Loadable** segment, described by `p_filesz` & `p_memsz`
    * Loadable  segment entries appear in ascending order, sorted on `p_vaddr`
  * `PT_DYNAMIC` Holds the  ****`.dynamic` section for **dynamic linking**
  * `PT_INTERP` Information on the **interpreter** to use \(if relevant\)
    * If present, it must precede any loadable segment entry
  *  `PT_NOTE` Holds the `.note` section
  * `PT_SHLIB` **Reserved** but unspecified semantics
  * `PT_PHDR` The location & size of the **program header table itself** in the file and in the memory image of the program
    * Most not be present more than once in a file and only if the program header table is part of the memory image of the program
    * If present, it must precede any loadable segment entry
  * `PT_GNU_STACK` GNU extension used by the Linux kernel to control the state of the stack via the flags set in `p_flags`
  * `PT_TLS`Thread Local Storage segment \(Common in statically linked binaries\)
* `p_offset` Its file offset
* `p_vaddr` Its virtual address
* `p_paddr` Its physical address \(when relevant\)
* `p_filesz`Size on disk, in bytes
* `p_memsz` Size in memory, in bytes
* `p_flags` A bit mask of flags
  * `PF_X`   An executable segment
  * `PF_W`   A writable segment
  * `PF_R`   A readable segment
  * A text segment commonly has the flags PF\_X and PF\_R
  * A data segment commonly has PF\_W and PF\_R
* `p_align` The value to which the segments are aligned in memory and in the file
  * Loadable process segments must have congruent values for `p_vaddr` & `p_offset`, modulo the page size
  * 0 & 1 means no alignment is required
  * Otherwise : 
    * `p_align` should be a positive, integral power of two
    * `p_vaddr` should equal `p_offset`, modulo `p_align`

### Section header table

* Locates all the file's sections
* It's an array of structures, there's 2 types of them, one for each architecture, but they don't differ except for types. Replace `XX` with `32` or `64` :

```c
typedef struct {
   uintXX_t   sh_name;
   uintXX_t   sh_type;
   uintXX_t   sh_flags;
   ElfXX_Addr sh_addr;
   ElfXX_Off  sh_offset;
   uintXX_t   sh_size;
   uintXX_t   sh_link;
   uintXX_t   sh_info;
   uintXX_t   sh_addralign;
   uintXX_t   sh_entsize;
} ElfXX_Shdr;
```

* `sh_name` Section name, can be used as an index for the string table
* `sh_type` Section type, those are :
  * `SHT_NULL` Marks the header as **inactive** \(it doesn't have an associated section\)
  * `SHT_PROGBITS` Holds information **defined by the program**
  * `SHT_SYMTAB` A complete **symbol table** that provides symbols for link editing or dynamic linking \(for which it would have more symbols than necessary\)
  * `SHT_STRTAB` A **string table**, there can be multiples
  * `SHT_RELA` **Relocation entries** with explicit addens, there can be multiples relocation sections
  * `SHT_HASH` A **symbol hash table** for ****dynamic linking
  * `SHT_DYNAMIC` Information for **dynamic linking**
  * `SHT_NOTE` This section holds **notes**
  * `SHT_NOBITS` Like `SHT_PROGBITS`but occupies no space in the file
    * Although it contains no bytes, `sh_offset` contains the conceptual file offset
    * It can also have a nonzero size
  * `SHT_REL` **Relocation offsets**, there can be multiple relocation sections
  * `SHT_SHLIB` Reserved but unspecified
  * `SHT_DYNSYM` A minimal set of **dynamic linking symbol**
* `sh_flags` A bit mask of flags
  * `SHF_WRITE` The section contains data that should be **writable** during process execution
  * `SHF_ALLOC` The section **occupies memory** during process execution
    * Some  sections do not reside in the memory image of an object file
  * `SHF_EXECINSTR` This section contains **executable** machine instructions
  * `SHF_MASKPROC` All bits included in this mask are reserved for **processor-specific** semantics
* `sh_addr` Its **virtual** **address**
* `sh_offset` Its **byte offset** on the disk
* `sh_size` Its size in **bytes**
* `sh_link` A section header table **index** **link**, whose interpretation depends on the section type
* `sh_info` Extra information, whose interpretation depends on the section type
* `sh_addralign` Some sections have **address alignment** constraints
  * The value of `sh_addr` must be congruent to zero,  modulo the value of `sh_addralign`
  * Only 0 and powers of 2 are allowed
  * 0 & 1 means no alignment is required
* `sh_entsize` Some sections hold a table of **fixed-sized entries**, this gives their size in bytes
* There's multiple possible sections :

<table>
  <thead>
    <tr>
      <th style="text-align:left">Name</th>
      <th style="text-align:left">Type</th>
      <th style="text-align:left">Attribute(s)</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left"><b><code>.bss</code></b>
      </td>
      <td style="text-align:left"><code>SHT_NOBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Uninitialized data, &quot;initialized&quot; to 0</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.comment</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Version control information</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.ctors</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Initialized pointers to the C++ constructor functions</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.data</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Initialized data</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.data1</code>
      </td>
      <td style="text-align:left"><code>Same</code>
      </td>
      <td style="text-align:left"><code>Same</code>
      </td>
      <td style="text-align:left">Same</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.debug</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Information for symbolic debugging, contents unspecified</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dtors</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Initialized pointers to the C++ destructor functions</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dynamic</code>
      </td>
      <td style="text-align:left"><code>SHT_DYNAMIC</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> and sometimes <code>SHF_WRITE</code> (processor specific)</td>
      <td
      style="text-align:left">Dynamic linking information</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dynstr</code>
      </td>
      <td style="text-align:left"><code>SHT_STRTAB</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">String table of <code>.dynsym</code>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dynsym</code>
      </td>
      <td style="text-align:left"><code>SHT_DYNSYM</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Dynamic linking symbol table</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.fini</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">Executable instructions for process termination</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.gnu.version</code>
      </td>
      <td style="text-align:left"><code>SHT_GNU_versym</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Version symbol table</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.gnu.version_r</code>
      </td>
      <td style="text-align:left"><code>SHT_GNU_versym</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Version symbol needed elements</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.got</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left">Processor-specific</td>
      <td style="text-align:left">Global offset table (dynamically linked global variables)</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.got.plt</code></b>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Global offset table (dynamically linked functions)</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.hash</code>
      </td>
      <td style="text-align:left"><code>SHT_HASH</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Symbol hash table</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.init</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">Executable instructions for initialization, it&apos;s executed before <code>main</code>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.interp</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left">If there&apos;s a loadable segment, <code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Pathname of an interpreter</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.line</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">
        <ul>
          <li>Line numbers for symbolic debugging (correspondence between source and
            machine code)</li>
          <li>Contents unspecified</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note</code>
      </td>
      <td style="text-align:left"><code>SHT_NOTE</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Various notes</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.ABI-tag</code>
      </td>
      <td style="text-align:left"><code>SHT_NOTE</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Declare the expected run-time ABI of the ELF image</li>
          <li>May include the os name and its run-time versions</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.gnu.build-id</code>
      </td>
      <td style="text-align:left"><code>SHT_NOTE</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Holds an ID uniquely identifying the contents of the ELF image</li>
          <li>Different files with the same build ID should contain the same executable
            content</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.GNU-stack</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Declare stack attributes, used by Linux object files</li>
          <li>Indicate to the GNU linker that the object file requires an executable
            stack</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.openbsd.ident</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left"></td>
      <td style="text-align:left">OpenBSD native executables usually contain this section to identify themselves
        so the kernel can bypass any compatibility ELF binary emulation tests when
        loading the file</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.plt</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left">Processor-specific</td>
      <td style="text-align:left">Procedure linkage table</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rel&lt;name&gt;</code>
      </td>
      <td style="text-align:left"><code>SHT_REL</code>
      </td>
      <td style="text-align:left">If there&apos;s a loadable segment with relocation, <code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Relocation table of a section of &lt;name&gt;, e.g the relocation table
            for <code>.dyn</code> will be <code>.rel.dyn</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rela&lt;name&gt;</code>
      </td>
      <td style="text-align:left"><code>SHT_RELA</code>
      </td>
      <td style="text-align:left">Same</td>
      <td style="text-align:left">Same</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rodata</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Initialized read-only data</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rodata1</code>
      </td>
      <td style="text-align:left">Same</td>
      <td style="text-align:left">Same</td>
      <td style="text-align:left">Same</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.shstrtab</code>
      </td>
      <td style="text-align:left"><code>SHT_STRTAB</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Section names</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.strtab</code>
      </td>
      <td style="text-align:left"><code>SHT_STRTAB</code>
      </td>
      <td style="text-align:left">If there&apos;s a loadable segment that includes the symbol string table, <code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">String table of <code>.symtab</code>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.symtab</code>
      </td>
      <td style="text-align:left"><code>SHT_SYMTAB</code>
      </td>
      <td style="text-align:left">
        <p>If there&apos;s a loadable segment that includes the symbol table,</p>
        <p><code>SHF_ALLOC</code>
        </p>
      </td>
      <td style="text-align:left">Global symbol table</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.text</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">Code</td>
    </tr>
  </tbody>
</table>

### String & Symbol table

* The object file uses strings to represent symbol and section names
  * These string are indexes in the string table
  * The first & last bytes of the string table are `\0`
* An object file's symbol table holds information needed to locate and relocate a program's symbolic definitions and references
* They're 2 versions of the structure, one for each architecture, replace the `XX` with `32` or `64`
  * The variables are the same, they're just in a different order

```c
typedef struct {
   uint32_t      st_name;
   unsigned char st_info;
   unsigned char st_other;
   uint16_t      st_shndx;
   Elf64_Addr    st_value;
   uint64_t      st_size;
} Elf64_Sym;
```

* `st_name` Index in the string table of the symbol name, if it's 0, it doesn't have one
* `st_info` A bit mask of flags indicating its type & binding attributes :
  * Binding attributes determine the linkage visibility & behavior when a the symbol is referenced by an external object
  * Common binding attributes are :
    * `STB_LOCAL` Not visible outside the file containing its definition
    * `STB_GLOBAL` Visible to all object files
    * `STB_WEAK`  Like global, but can be overwritten
  * Common types are :
    * `STT_NOTYPE` Not defined
    * `STT_OBJECT` Data object \(a variable\)
    * `STT_FUNC` Code object \(function\)
    * `STT_SECTION` Section \(Binding : `STB_LOCAL`\)
    * `STT_FILE` Source file associated with the object file
      * Binding : `STB_LOCAL` 
      * Section index : `SHN_ABS`
      * It  precedes the other  `STB_LOCAL` symbols of the file
  * There are macros for packing and unpacking the binding & type fields from an `st_info`
    * Replace XX by architecture number
    * `ELFXX_ST_BIND(info)` Extract the binding, equivalent to `((info) >> 4)`
    * `ELFXX_ST_TYPE(info)` Extract the type, equivalent to `((info) & 0xf)`
    * `ELFXX_ST_INFO(bind, type)` Pack a binding & type into an `st_info`
* `st_other` Its visibility, defines how it may be accessed once it's part of an executable or shared object, some common visibility :
  * `STV_DEFAULT` Default visibility rules, defined by it's binding type
  * `STV_INTERNAL` Processor-specific hidden class
  * `STV_HIDDEN` Not visible to other objects
  * `STV_PROTECTED` Visible to other objects, but references in the local one always resolve to the local symbol
  * A macro exist to extract the visibility `ELFXX_ST_VISIBILITY(o)`
    * Replace `XX` by the architecture \(`32` or `64`\)
    * The only relevant contents of this field are its 3 last significant bits
    * Equivalent to `((o) & 0x3)`
* `st_shndx` Index in the section header table of the symbol section
* `st_value` Its value for a given symbol table entry, its interpretation depend on the object type
  * For `ET_REL` files, it holds a section offset
    * The section in which this offset resides is specified on its `st_shndx`
  * For `ET_EXEC` / `ET_DYN` files, it holds a virtual address
    * If it contains 0 and the symbol’s section pointed by `st_shndx` has a `sh_type` of type `SHT_UNDEF`, the symbol is an imported relocation and its value will be resolved at runtime by the RTLD \(ld.so\)
* `st_size` Its size, 0 for no or unknown

### Relocation

* Relocation is the process of connecting a symbol's reference to a definition
* They describe how to modify their section content
* There's 4 structures total, depending of the architecture and the presence of addend, replace `XX` by `32` or  `64`

```c
// Without addend

typedef struct {
   ElfXX_Addr r_offset;
   uintXX_t   r_info;
} ElfXX_Rel;

// With addend :

typedef struct {
   ElfXX_Addr r_offset;
   uintXX_t   r_info;
   intXX_t    r_addend;
} ElfXX_Rela;
```

* `r_offset` The location at which to apply the relocation
  * For `ET_REL` \(elf object type\), it's an offset within the section header
  * For `ET_EXEC`, its a virtual address
* `r_info` Bit mask for the symbol table index and the type of relocation \(which are processor-specific\)
  * We can extract it's value with those macros :
  * `ELF32_R_SYM(info)` : `((info)>>8)`
  * `ELF32_R_TYPE(info)` : `((unsigned char)(info))`
  * `ELF64_R_SYM(info)` : `((info)>>32)`
  * `ELF64_R_TYPE(info)` : `((Elf64_Word)(info))`
* `r_addend` A constant addend used to be added to compute the value to be stored into the relocatable field

### Dynamic type

* Structures relevant for dynamic linking

```c
typedef struct {
   Elf32_Sword    d_tag;
   union {
       Elf32_Word d_val;
       Elf32_Addr d_ptr;
   } d_un;
} Elf32_Dyn;
extern Elf32_Dyn _DYNAMIC[];

typedef struct {
   Elf64_Sxword    d_tag;
   union {
       Elf64_Xword d_val;
       Elf64_Addr  d_ptr;
   } d_un;
} Elf64_Dyn;
extern Elf64_Dyn _DYNAMIC[];
```

* `d_tag` controls the interpretation of `d_un`
  * There's a looot of d\_tag, so i won't list them
* `d_val` Various interpretations
* `d_ptr`  Program virtual addresses
  * When interpreting these addresses, the actual address should be computed based on the original file value and memory base address
* `_DYNAMIC` Array of all the structures in the `.dynamic` section
  * Automatically populated by the linker

### Notes

* The `.notes` section contains a series of structure, each followed by a name field and a descriptor field
* They're largely used by core files, but many projects also define their own set of extensions
* There's 2 structures, one for each architecture

```c
typedef struct {
   Elf32_Word n_namesz;
   Elf32_Word n_descsz;
   Elf32_Word n_type;
} Elf32_Nhdr;

typedef struct {
   Elf64_Word n_namesz;
   Elf64_Word n_descsz;
   Elf64_Word n_type;
} Elf64_Nhdr;
```

*  `n_namesz`The length \(with `\0`\) of the name field in bytes

  * The contents will immediately follow this note in memory

  `n_descsz` The length of the descriptor field in bytes

  * The contents will immediately follow the name field in memory

*  `n_type` Depending on the value of the name field, this will change. There's a lot of possible values, i won't list them

## Notes

* The Executable and Linkable Format, also known as ELF, is the generic file format for executables in Linux systems
* Sections comprise all information needed for linking a target object file in order to build a working executable. \(It’s important to highlight that sections are needed on linktime but they are not needed on runtime.\) In every ELF executable, there is a Section Header Table. This table is an array of Elfxx\_Shdr structures, having one Elfxx\_Shdr entry per section.
* Segments, which are commonly known as Program Headers, break down the structure of an ELF binary into suitable chunks to prepare the executable to be loaded into memory. In contrast with Section Headers, Program Headers are not needed on linktime.
* On the other hand, similarly to Section Headers, every ELF binary contains a Program Header Table which comprises of a single Elfxx\_Phdr structure per existing segment.
* Something important to highlight about segments is that only PT\_LOAD segments get loaded into memory. Therefore, every other segment is mapped within the memory range of one of the PT\_LOAD segments.
* In order to understand the relationship between Sections and Segments, we can picture segments as a tool to make the linux loader’s life easier, as they group sections by attributes into single segments in order to make the loading process of the executable more efficient, instead of loading each individual section into memory
  * see img
* Another important aspect of segments is that their offsets and virtual addresses must be congruent modulo the page size and their p\_align field must be a multiple of the system page size.

  The reason for this alignment is to prevent the mapping of two different segments within a single memory page. This is due to the fact that different segments usually have different access attributes, and these cannot be enforced if two segments are mapped within the same memory page. Therefore, the default segment alignment for PT\_LOAD segments is usually a system page size.

* In the development process of a program, we often use names to refer toa objects in our code, such as functions or variables that are used all throughout the program. This information is what is known as the program’s symbolic information. Symbolic references in machine code get translated into offsets and addresses on the compilation process.
  * However, compilers are not limited to machine code generation; they also export symbolic information from source code. Symbolic information is exported in order to improve the interpretation of the generated machine code.
* A wide range of tools interact with symbols to enforce their functionality. One example of these tools are Linkers
  * Another example of tools that heavily depend on symbolic information are Debuggers
  * Debugging without symbols implies that one has no ability to identify functions or variables by name among other impediments.
* The major difference between symbol visibility and symbol binding is that the former is enforced on the host object of a given symbol and applies to any external object referencing it. Symbol binding, on the other hand, is specified by an external object referencing the symbol and is enforced at link-time. In other words, object binding depends on the object referencing the symbol, while symbol visibility depends on how the object containing the symbol was compiled
* Every symbol entry within the Symbol Table is associated with a section
* `(st_shndx`\)Common values for section type field include:
  * SHT\_UNDEF: section is not present in current object. This value is typically set in symbols that have been imported from external objects.
  * SHT\_PROGBITS: section is defined in current object.
  * SHT\_SYMTAB, SHT\_DYNSYM: Symbol Table \(.symtab, .dynsym\).
  * SHT\_STRTAB, SHT\_DYNSTR:  String Table \(.strtab, .dynstr\).
  * SHT\_REL: Relocation Table without explicit addends \(.rel.dyn, .rel.plt\).
  * SHT\_RELA: Relocation Table with explicit addends \(.rela.dyn, .rela.plt\).
  * SHT\_HASH: Hash Table for dynamic symbol resolution \(.gnu.hash\)
  * SHT\_DYNAMIC: section holding Dynamic Linking information \(.dynamic\)
  * SHT\_NOBITS: section takes no space in disk \(.bss\)
* We refer .symtab as the binary’s global Symbol Table, containing all symbol references in the current object. The section .strtab is the String Table of .symtab Symbol Table. String Tables store null-terminated strings used to reference objects from a different section. Each String Table contains the exact number of entries as its corresponding Symbol Table. This entails that each string entry at a given index in .strtab corresponds to an Elfxx\_Sym entry at the same index in .symtab.
* On the other hand, we have .dynsym Symbol Table. This Symbol Table only holds symbols needed for Dynamic Linking.
  * If a given binary has been stripped \(.symtab/.strtab have been removed\) and this same binary has been compiled so that a subset of its symbols will be dynamically linked, this subset of symbols can be recovered by parsing .dynsym table located at DT\_SYMTAB entry within PT\_DYNAMIC segment. For dynamically linked executables, .dynsym will not be removed even if target binary has been stripped, since it is needed at runtime by the RTLD in the process of Dynamic Linking.
  * As with .symtab, .dynsym has its own string table called .dynstr. All the relationships previously covered between .symtab and .strtab also apply between .dynsym and .dynstr
* The mechanism of connecting symbolic references with their correspondent symbolic definitions is what is know as Relocations.
  * In order for those variables to be successfully referenced in our program, their addresses within the process virtual address space have to be resolved.
  * Populating symbolic references on symbolic definitions takes place during the linking phase of the compilation process.
  * Relocation information is held in relocatable entries, located in specific relocation sections within an ELF object.
  * There are two different Relocation entry structures: Elfxx\_Rel and Elfxx\_Rela:
    * It is important to note that these relocation entry types are mutually exclusive within the context of a given ELF object. This means that if one type of entry is used, the other one will not be used consequently
  * These relocation entries are always found in some relocation section.
    * As mentioned before, the relocation section is linked to two other sections. One of them is the symbol table, where the symbols that will be relocated are held.
    * The additional section linked to the relocation section is where the relocations are going to take place
    * A relocation section will always be linked to its correspondent symbol table. This symbol table can be located as a section in the Section Header Table, and its index can be retrieved by the sh\_link field of the relocation section’s Elfxx\_Shdr instance.
    * As previously mentioned, if a file is of type ET\_REL, a given relocation entry’s r\_offset will be an offset to a particular section where a relocation has to take place. The section index where to apply that offset can be retrieved by the relocation section’s Elfxx\_Shdr sh\_info field.
* There are different types of relocatable files:
  * Generic object files \(\*.o\).
  * Kernel object files \(\*.ko\).
  * Shared object files \(\*.so\).
* Generic object files are the ones that are used for static linking
  * On the benefits side, we should note that there is no need to rely on external dependencies to make the main executable work across different hosts. On the other hand, statically linked executables can become particularly large, since all needed dependencies of a given program will become part of the generated binary itself as previously mentioned.
* Furthermore, another type of relocatable object are Kernel objects. These type of objects support being loaded to the kernel as a module \(commonly known as LKM\), without the need to restart the system.
* There are also shared objects. These type of relocatable files support being linked on runtime, and they may be shared across different processes. Consequently, relocations of dynamic dependencies have to be done at runtime. This process is known as Dynamic Linking.
* Image bases of dynamically linked dependencies are not deterministic, since they will differ even between different process instances of the same executable. Furthermore, as an interesting fact, dynamic dependencies in Linux systems do not have preferred based image bases, as is the case with Windows systems – Process A libc.so will not be mapped at the same address as process B libc.so.
* 
## Source

* Manual pages

