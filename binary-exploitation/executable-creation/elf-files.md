# ELF Files

## Introduction

* ELF stands for **Executable & Linkable Format**, its the generic executable format on Linux
* An elf file can be :
  * A relocatable object file
  * An executable
  * A core file
  * A shared object
* An ELF file is composed of :
  * An header
  * An optional program header \(for executable and shared object files\)
  * An optional section header \(for linking\)

{% hint style="info" %}
Search google for Relocatable vs Shared object
{% endhint %}

## Header

The header is described as a C struct :

```c
#define EI_NIDENT 16

typedef struct {
    unsigned char e_ident[EI_NIDENT];
    uint16_t      e_type;
    uint16_t      e_machine;
    uint32_t      e_version;
    ElfN_Addr     e_entry;
    ElfN_Off      e_phoff;
    ElfN_Off      e_shoff;
    uint32_t      e_flags;
    uint16_t      e_ehsize;
    uint16_t      e_phentsize;
    uint16_t      e_phnum;
    uint16_t      e_shentsize;
    uint16_t      e_shnum;
    uint16_t      e_shstrndx;
} ElfN_Ehdr;
```

* `e_ident` An array specifying how to interpret the file, its bytes are divided as follows :
  * Each byte can be access through it's "name", for example `e_ident[EI_MAGO]`
  * Bytes 0-1-2-3 \(`EI_MAG0`-`EI_MAG1`-`EI_MAG2`-`EI_MAG3`\) : Must be `0x7fELF`
  * Byte 4 \(`EI_CLASS`\) - Identifies the architecture, can be:
    * 1 for `ELFCLASS32`
    * 2 for `ELFCLASS64`
  * Byte 5 \(`EI_DATA`\) - Specify the encoding, can be :
    * 1 for `ELFDATA2LSB` : 2's complement, little-endian
    * 2 for `ELFDATA2MSB` : 2's complement, big-endian
  * Byte 6 \(`EI_VERSION`\) : ELF's specification version
  * Byte 7 \(`EI_OSABI`\) : Specify the targeted OS and Application Binary Interface \(ABI\), there's multiple so I won't list them
  * Byte 8 \(`EI_ABIVERSION`\) : Version of the specified ABI
  * Byte 9-14 \(`EI_PAD`\) : Reserved bytes set to 0
  * Byte 15 \(`EI_NIDENT`\) : The size of the array
* `e_type` The type of ELF file
  * `ET_REL` A relocatable file
  * `ET_EXEC` An executable file
  * `ET_DYN` A shared object
  * `ET_CORE` A core file
* `e_machine` Specifies the required architecture for an individual file, there's multiple so i won't list them
* `e_version` The version of the file
* `e_entry`The virtual address to which the system first transfers control, thus starting the process
* `e_phoff`The program header table's offset in bytes
* `e_shoff`The section header table's offset in bytes
* `e_flags` __Holds processor-specific flags associated with the file
  * Flag names take the form `EF<machine_flag>`
  * Currently, no flags defined
* `e_ehsize` The ELF header's size in bytes
* `e_phentsize` A segment size in byte, all are the same size
* `e_phnum` The number of segment
  * If it's &gt;= 0xffff, it holds `0xffff` and the real number is in the `sh_info` of the first section header
* `e_shentsize` A section header size in bytes, all are the same size
* `e_shnum` The number of section headers
  * If it's &gt;= 0xffff, it holds `0xffff` and the real number is in the `sh_info` of the first section header
* `e_shstrndx` The index within the section header table of the string table containing the section names
  * If it's &gt;= 0xff00, it holds `0xffff` and the real index is held in the `sh_link`of the first header

### Program header table

* **Segments**, or program headers, divide the code into multiple part
  * They groups **sections** \(see below\) by attributes together to make loading them more efficient
  * Only needed at runtime
* The program header table is an array of structures, each describing a segment
* There's 2 structures depending on the architecture, replace `XX` to `32` or `64` :
  * The difference is the position of the `p_flags` variable

```c
typedef struct {
   uintXX_t   p_type;
   ElfXX_Off  p_offset;
   ElfXX_Addr p_vaddr;
   ElfXX_Addr p_paddr;
   uintXX_t   p_filesz;
   uintXX_t   p_memsz;
   uintXX_t   p_flags;
   uintXX_t   p_align;
} ElfXX_Phdr;
```

* `p_type` Some available types : 
  * `PT_NULL` **Unassigned** segment \(usually 1st entry of the program header table\)
  * `PT_LOAD` **Loadable** segment, described by `p_filesz` & `p_memsz`
    * Those are loaded into memory, however, there must only be one 1 per memory page since they don't have the same access attributes
    * Since they're the only segments loaded into memory, the other ones are mapped within the memory range of one of the `PT_LOAD` segments
    * To avoid overlap, the default segment size is the one of a page
    * Loadable  segment entries appear in ascending order, sorted on `p_vaddr`
  * `PT_DYNAMIC` Holds the  ****`.dynamic` section for **dynamic linking**
  * `PT_INTERP` Information on the **interpreter** to use \(if relevant\)
    * If present, it must precede any loadable segment entry
  *  `PT_NOTE` Holds the `.note` section
  * `PT_SHLIB` **Reserved** but unspecified semantics
  * `PT_PHDR` The location & size of the **program header table itself** in the file and in the memory image of the program
    * Mustn't be present more than once and if present, it must precede any loadable segment entry
  * `PT_GNU_STACK` GNU extension used by the Linux kernel to control the state of the stack via the flags in `p_flags`
  * `PT_TLS`Thread Local Storage segment \(common in statically linked binaries\)
* `p_offset` Its file offset
* `p_vaddr` Its virtual address
* `p_paddr` Its physical address
* `p_filesz`Size on disk, in bytes
* `p_memsz` Size in memory, in bytes
* `p_flags` A bit mask of flags
  * `PF_X`   An executable segment
  * `PF_W`   A writable segment
  * `PF_R`   A readable segment
  * A text segment commonly has the flags PF\_X and PF\_R
  * A data segment commonly has PF\_W and PF\_R
* `p_align` The value to which the segments are aligned in memory and in the file
  * Loadable process segments must have congruent values for `p_vaddr` & `p_offset`, modulo the page size
  * 0 & 1 means no alignment is required
  * Otherwise : 
    * `p_align` should be a positive, integral power of two
    * `p_vaddr` should equal `p_offset`, modulo `p_align`

### Section header table

* A section header is an array of structure describing a section
  * Some indexes are reserved, like the first one
* A section contain all the information needed for linking the object file
* It's not needed at runtime
* It's an array of structures, there's 2 types of them, one for each architecture, but they don't differ except for types. Replace `XX` with `32` or `64` :

```c
typedef struct {
   uintXX_t   sh_name;
   uintXX_t   sh_type;
   uintXX_t   sh_flags;
   ElfXX_Addr sh_addr;
   ElfXX_Off  sh_offset;
   uintXX_t   sh_size;
   uintXX_t   sh_link;
   uintXX_t   sh_info;
   uintXX_t   sh_addralign;
   uintXX_t   sh_entsize;
} ElfXX_Shdr;
```

* `sh_name` Section name, can be used as an index for the string table
* `sh_type` Section type, those are :
  * `SHT_NULL` Marks the header as **inactive** \(it doesn't have an associated section\)
  * `SHT_PROGBITS` Holds information **defined by the program**
  * `SHT_SYMTAB`, `SHT_DYNSYM` Static & dynamic **symbol tables** 
  * `SHT_STRTAB` A **string table**, there can be multiples
  * `SHT_REL` **Relocation w/o addens**, there can be multiple relocation sections
  * `SHT_RELA` **Relocation w/ addens**, there can be multiples relocation sections
  * `SHT_HASH` A **symbol hash table** for ****dynamic linking
  * `SHT_DYNAMIC` Information for **dynamic linking**
  * `SHT_NOTE`
  * `SHT_NOBITS` Holds information **defined by the program**, but they don't occupy space
    * Although it contains no bytes, `sh_offset` contains the conceptual file offset
  * `SHT_SHLIB` Reserved but unspecified
* `sh_flags` A bit mask of flags
  * `SHF_WRITE` The section contains data that should be **writable** during process execution
  * `SHF_ALLOC` The section **occupies memory** during process execution
  * `SHF_EXECINSTR` This section contains **executable** machine instructions
  * `SHF_MASKPROC` All bits included in this mask are reserved for **processor-specific** semantics
* `sh_addr` Its **virtual** **address**
* `sh_offset` Its **byte offset** on the disk
* `sh_size` Its size in **bytes**
* `sh_link` An **index** **link**, whose interpretation depends on the section type
  * For relocation sections, its the index within the section header table of its corresponding symbol table section
* `sh_info` Extra information, whose interpretation depends on the section type
* `sh_addralign` Some sections have **address alignment** constraints
  * The value of `sh_addr` must be congruent to zero,  modulo the value of `sh_addralign`
  * Only 0 and powers of 2 are allowed
  * 0 & 1 means no alignment is required
* `sh_entsize` Some sections hold a table of **fixed-sized entries**, this gives their size in bytes

### Some possible sections

<table>
  <thead>
    <tr>
      <th style="text-align:left">Name</th>
      <th style="text-align:left">Type</th>
      <th style="text-align:left">Attribute(s)</th>
      <th style="text-align:left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left"><b><code>.bss</code></b>
      </td>
      <td style="text-align:left"><code>SHT_NOBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Uninitialized data, &quot;initialized&quot; to 0</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.comment</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Version control information</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.ctors</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Initialized pointers to the C++ constructor functions</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.data</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Initialized data</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.data1</code>
      </td>
      <td style="text-align:left"><code>Same</code>
      </td>
      <td style="text-align:left"><code>Same</code>
      </td>
      <td style="text-align:left">Same</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.debug</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Information for symbolic debugging, contents unspecified</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dtors</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_WRITE</code>
      </td>
      <td style="text-align:left">Initialized pointers to the C++ destructor functions</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dynamic</code>
      </td>
      <td style="text-align:left"><code>SHT_DYNAMIC</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> and sometimes <code>SHF_WRITE</code> (processor specific)</td>
      <td
      style="text-align:left">Dynamic linking information</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dynstr</code>
      </td>
      <td style="text-align:left"><code>SHT_STRTAB</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">String table of <code>.dynsym</code>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.dynsym</code>
      </td>
      <td style="text-align:left"><code>SHT_DYNSYM</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Dynamic linking symbol table</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.fini</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">Executable instructions for process termination</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.gnu.version</code>
      </td>
      <td style="text-align:left"><code>SHT_GNU_versym</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Version symbol table</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.gnu.version_r</code>
      </td>
      <td style="text-align:left"><code>SHT_GNU_versym</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Version symbol needed elements</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.got</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left">Processor-specific</td>
      <td style="text-align:left">Global offset table (dynamically linked global variables)</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.got.plt</code></b>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Global offset table (dynamically linked functions)</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.hash</code>
      </td>
      <td style="text-align:left"><code>SHT_HASH</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Symbol hash table</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.init</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">Executable instructions for initialization, it&apos;s executed before <code>main</code>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.interp</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left">If there&apos;s a loadable segment, <code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Pathname of an interpreter</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.line</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">
        <ul>
          <li>Line numbers for symbolic debugging (correspondence between source and
            machine code)</li>
          <li>Contents unspecified</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note</code>
      </td>
      <td style="text-align:left"><code>SHT_NOTE</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Various notes</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.ABI-tag</code>
      </td>
      <td style="text-align:left"><code>SHT_NOTE</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Declare the expected run-time ABI of the ELF image</li>
          <li>May include the os name and its run-time versions</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.gnu.build-id</code>
      </td>
      <td style="text-align:left"><code>SHT_NOTE</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Holds an ID uniquely identifying the contents of the ELF image</li>
          <li>Different files with the same build ID should contain the same executable
            content</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.GNU-stack</code>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Declare stack attributes, used by Linux object files</li>
          <li>Indicate to the GNU linker that the object file requires an executable
            stack</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.note.openbsd.ident</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left"></td>
      <td style="text-align:left">OpenBSD native executables usually contain this section to identify themselves
        so the kernel can bypass any compatibility ELF binary emulation tests when
        loading the file</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.plt</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left">Processor-specific</td>
      <td style="text-align:left">Procedure linkage table</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rel&lt;name&gt;</code>
      </td>
      <td style="text-align:left"><code>SHT_REL</code>
      </td>
      <td style="text-align:left">If there&apos;s a loadable segment with relocation, <code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">
        <ul>
          <li>Relocation table of a section of &lt;name&gt;, e.g the relocation table
            for <code>.dyn</code> will be <code>.rel.dyn</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rela&lt;name&gt;</code>
      </td>
      <td style="text-align:left"><code>SHT_RELA</code>
      </td>
      <td style="text-align:left">Same</td>
      <td style="text-align:left">Same</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.rodata</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">Initialized read-only data</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.rodata1</code>
      </td>
      <td style="text-align:left">Same</td>
      <td style="text-align:left">Same</td>
      <td style="text-align:left">Same</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.shstrtab</code>
      </td>
      <td style="text-align:left"><code>SHT_STRTAB</code>
      </td>
      <td style="text-align:left"></td>
      <td style="text-align:left">Section names</td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.strtab</code>
      </td>
      <td style="text-align:left"><code>SHT_STRTAB</code>
      </td>
      <td style="text-align:left">If there&apos;s a loadable segment that includes the symbol string table, <code>SHF_ALLOC</code>
      </td>
      <td style="text-align:left">String table of <code>.symtab</code>
      </td>
    </tr>
    <tr>
      <td style="text-align:left"><code>.symtab</code>
      </td>
      <td style="text-align:left"><code>SHT_SYMTAB</code>
      </td>
      <td style="text-align:left">
        <p>If there&apos;s a loadable segment that includes the symbol table,</p>
        <p><code>SHF_ALLOC</code>
        </p>
      </td>
      <td style="text-align:left">Global symbol table</td>
    </tr>
    <tr>
      <td style="text-align:left"><b><code>.text</code></b>
      </td>
      <td style="text-align:left"><code>SHT_PROGBITS</code>
      </td>
      <td style="text-align:left"><code>SHF_ALLOC</code> &amp; <code>SHF_EXECINSTR</code>
      </td>
      <td style="text-align:left">Code</td>
    </tr>
  </tbody>
</table>

### Symbol table

* Symbols refers to object in code, like variables & functions
  * Their strings are stored in a **string table**
    * Its first & last entries are `\0`
  * They're replaced by absolute addresses during the linking phase of compilation
    * Compilers can also export the symbolic information to make debugging easier
* There's 2 versions of the symbol structure, one for each architecture :

  * The variables are the same, they're just in a different order
  * Replace `XX` by `32` or `64`

  ```c
  typedef struct {
     uint32_t      st_name;
     unsigned char st_info;
     unsigned char st_other;
     uint16_t      st_shndx;
     ElfXX_Addr    st_value;
     uintXX_t      st_size;
  } Elf64_Sym;
  ```

  * `st_name` Index of the symbol name in the string table, if it's 0, it doesn't have one
  * `st_info` A bit mask of flags indicating its type & binding attributes :
    * Common types are :
      * `STT_NOTYPE` Not defined
      * `STT_OBJECT` Data object \(a variable\)
      * `STT_FUNC` Code object \(a function\)
      * `STT_SECTION` Section \(Binding : `STB_LOCAL`\)
      * `STT_FILE` Source file associated with the object file
        * Binding : `STB_LOCAL` 
        * It  precedes the other  `STB_LOCAL` symbols of the file
    * Binding attributes determine the linkage visibility & behavior when a symbol is referenced by an external object
    * Common binding attributes are :
      * `STB_LOCAL` Not visible outside the file containing its definition
      * `STB_GLOBAL` Visible to all object files
      * `STB_WEAK`  Like global, but can be overwritten
    * There are macros for packing and unpacking the binding & type fields from an `st_info`
      * Replace XX by architecture number
      * `ELFXX_ST_BIND(info)` Extract the binding, equivalent to `((info) >> 4)`
      * `ELFXX_ST_TYPE(info)` Extract the type, equivalent to `((info) & 0xf)`
      * `ELFXX_ST_INFO(bind, type)` Pack a binding & type into an `st_info`
  * `st_other` Its visibility
    * Visibility defines how it may be accessed once it's part of an executable or shared object
    * `STV_DEFAULT` Default visibility rules, defined by it's binding type
    * `STV_INTERNAL` Processor-specific hidden class
    * `STV_HIDDEN` Not visible to other objects
    * `STV_PROTECTED` Visible to other objects, but references in the local one always resolve to the local symbol
    * A macro exist to extract the visibility `ELFXX_ST_VISIBILITY(o)`
      * Replace `XX` by the architecture \(`32` or `64`\)
      * The only relevant contents of this field are its 3 last significant bits
      * Equivalent to `((o) & 0x3)`
  * `st_shndx` Index within the section header table of the section that reference it
  * `st_value` Its address, the interpretation depend on the object file type
    * For `ET_REL` files, it holds a section offset in the section specified by `st_shndx`
    * For `ET_EXEC` / `ET_DYN` files, it holds a virtual address
      * If it contains 0 and the section pointed by `st_shndx` is of type `SHT_UNDEF`, the symbol is an imported relocation and its value will be resolved at runtime by the RTLD
  * `st_size` Its size, 0 for no or unknown

### Relocation

* There's 4 structures total, depending of the architecture and the presence of addend
  * Replace `XX` by `32` or  `64`
  * Rel & Rela are mutually exclusive, if one is used, the other won't be

```c
// Without addend

typedef struct {
   ElfXX_Addr r_offset;
   uintXX_t   r_info;
} ElfXX_Rel;

// With addend :

typedef struct {
   ElfXX_Addr r_offset;
   uintXX_t   r_info;
   intXX_t    r_addend;
} ElfXX_Rela;
```

* `r_offset` The location at which to apply the relocation
  * For `ET_REL` files, it's an offset within the section header
  * For `ET_EXEC` files, its a virtual address
* `r_info` Bit mask for the symbol table index and the type of relocation
  * The type of relocation are processor-specific and describe what the linker should do with the value of the concerned symbol to compute the final address
  * The difference between types is the way the relocated value is calculated
  * We can extract it's value with those macros :
    * `ELF32_R_SYM(info)` : `((info)>>8)`
    * `ELF32_R_TYPE(info)` : `((unsigned char)(info))`
    * `ELF64_R_SYM(info)` : `((info)>>32)`
    * `ELF64_R_TYPE(info)` : `((Elf64_Word)(info))`
* `r_addend` A constant addend to compute the value to be stored into the relocatable field
* The index of the corresponding symbol table section is written in the relocation section header

### Dynamic type

* Structures relevant for dynamic linking, one for each architecture

```c
typedef struct {
   Elf32_Sword    d_tag;
   union {
       Elf32_Word d_val;
       Elf32_Addr d_ptr;
   } d_un;
} Elf32_Dyn;
extern Elf32_Dyn _DYNAMIC[];

typedef struct {
   Elf64_Sxword    d_tag;
   union {
       Elf64_Xword d_val;
       Elf64_Addr  d_ptr;
   } d_un;
} Elf64_Dyn;
extern Elf64_Dyn _DYNAMIC[];
```

* `d_tag` controls the interpretation of `d_un`
  * There's a looot of d\_tag, so i won't list them
* `d_val` Various interpretations
* `d_ptr`  Program virtual addresses
  * When interpreting these addresses, the actual address should be computed based on the original file value and memory base address
* `_DYNAMIC` Array of all the structures in the `.dynamic` section
  * Automatically populated by the linker

### Notes

* The `.notes` section contains a series of structure, each followed by a name field and a descriptor field
* They're largely used by core files, but many projects also define their own set of extensions
* There's 2 structures, one for each architecture, replace `XX` with `32` or `64`

```c
typedef struct {
   ElfXX_Word n_namesz;
   ElfXX_Word n_descsz;
   ElfXX_Word n_type;
} ElfXX_Nhdr;
```

*  `n_namesz`The length in byte \(with `\0`\) of the name field

  * The contents will immediately follow this note in memory

  `n_descsz` The length in byte of the descriptor field

  * The contents will immediately follow the name field in memory

*  `n_type` Depending on the value of the name field, this will change. There's a lot of possible values, i won't list them

## Notes

* For statically linked programs, execution is straight forward. The system creates the memory layout from the file’s segments and passes control to the file’s entry point.
*  With dynamically linked programs, the system executes the file’s “interpreter”, which is an intermediate program that should set up the environment and only then execute the main binary. The interpreter lies in the _PT\_INTERP_ segment created by the compile-time linker \(_**ld**_\). In this case, the interpreter is the dynamic linker program **ld-linux.so.2**:
*  The dynamic linker will set up the environment using dynamic entries from the _.dynamic_ section:
*  * **DT\_NEEDED** – the name of a required dependency to load.
  * **DT\_SYMTAB** – the address of the dynamic symbol table \(covered in our [previous blog post](https://intezer.com//executable-linkable-format-101-part-2-symbols/) about symbols\).
  * **DT\_FLAGS** – such as the BIND\_NOW flag that instructs the dynamic linker to perform all linking before handing over control to the program.
* **Lazy linking** is an optimization for this problem. Lazy linking instructs the dynamic linker to resolve function references when they are called \(lazily\) instead of at load-time \(eagerly\).

  This is enabled by the **Procedure Linkage Table \(PLT\)** and the **Global Offset Table \(GOT\)**.

  The GOT holds entries of addresses of global variables and external functions.

  The PLT consists of short entries of instructions \(often called “trampolines” or “thunks”\), used to reach external functions by redirecting control flow of execution to its corresponding GOT entry.

  Generally speaking, in dynamically linked executables, external functions are reached by calling their respective PLT entry:

* call \_printf@plt
  * The PLT entry will retrieve the function’s address from the function’s GOT entry, and call it:
  * With early binding, GOT entries are relocated by the dynamic linker at load-time.
  * With lazy linking, the GOT entries will be relocated on-demand by a function call. At a function’s first invocation, the PLT will be used to call the dynamic linker to link the missing function.

## Relocation process

* .got - Global offset table \(dynamically linked global variables\) 
  * This is the actual table of offsets as filled in by the linker for external symbols
* .plt This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the `.got.plt` section, and either jump to the right address, or trigger the code in the linker to look up the address. \(If the address has not been filled in to `.got.plt` yet.\)
* .got.plt This is the GOT for the PLT. It contains the target addresses \(after they have been looked up\) or an address back in the `.plt` to trigger the lookup. Classically, this data was part of the `.got` section.
  *  the `.got.plt` section is basically a giant array of function pointers
* .dynamic: The structure residing at the beginning of the section holds the addresses of other dynamic linking information.
* .got and .plt \(procedure linkage table\): .got stores the addresses of system functions and the .plt stores indirect links into the GoT
* the section is the .got.plt section, which is a specific section dedicated to hold a table of pointers, as an interface for the application to access relocated dynamically linked procedures addresses.
* \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add
* readelf

## Source

* Manual pages
* Intezer.com articles : [1](https://www.intezer.com/blog/research/executable-linkable-format-101-part1-sections-segments/), [2](https://www.intezer.com/blog/elf/executable-linkable-format-101-part-2-symbols/), [3](https://www.intezer.com/blog/elf/executable-and-linkable-format-101-part-3-relocations/), [4](https://www.intezer.com/blog/elf/executable-linkable-format-101-part-4-dynamic-linking/)

