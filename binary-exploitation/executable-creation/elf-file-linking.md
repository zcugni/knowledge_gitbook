# ELF file linking

### Static Relocation

### Dynamic relocation

* During compilation of the object file, the linker can resolve all internal references to symbols but at runtime it needs to resolve the external ones
* To do that, there's 2 solutions :
  * Load-time relocation
  * Position-Independent Code

### Load-time relocation

### Position-independent code

* Position independent code doesn't care about its final address, since all reference are relative, it will work not matter where it is loaded
* This is the most common technique now, because of it's advantages compared to load-time relocation :
  * ....
* Compared to load-time relocation, this technique handle the relocation from the data segment instead of the text one, this has 2 advantages :
  * The text segment can remain read-only, and as such be shareable to other processes
  * The relocation is done per symbol instead of per symbol reference
* To do that, it uses the **Global Offset Table** \(`.got`\)and the **Procedure Linkage Table** \(`.plt`\)
  * The `.got` is an array of pointers which can be 2 things :
    * Absolute addresses for variables
    * Jump to `.plt` for functions
  * The `.plt` is...
* This is the process when a symbol reference to a **global variable** occurs in an instruction :
  * Instead of directly replacing it with its absolute address :
    * The absolute address is written in the `.got` section
    * The offset of the entry within `.got` is written in the `st_value` of the symbol
    * The index of `.got` within the section header table is written in the `st_shndx` of the symbol
  * The offset of an instruction within the `.text` section is actually what the value of `eip` will be at this instruction
  * The linker knows the address of the sections, so if it can retrieve `eip` at the instruction with the symbol reference, it can deduce the offset between it and `.got`
    * However, there's no instruction for retrieving `eip`, but a small trick does it :
      * `call` a function which has only one instruction : `pop <reg>`
      * This work because when a call occurs, the next instruction to be executed is pushed to the stack
  * With all that, to replace the symbol we need to :
    * `call` to a function that only `pop` the `eip` into a register
    * `add`  to `eip` a computed offset to the start of the `.got` 
    * `add` to the start of `.got` the offset of the corresponding entry of the symbol
    * Copy the value pointed by the entry at the place of the symbol
* With **functions**, the process isn't as straightforward
  * To avoid relocating all the functions when some of them might not be used we use lazy relocation
    * Thinks of libraries, often only a fraction of their functions are used
  * This lazy evaluation is done through the `.plt`
    * The symbol reference is replaced by a `call` to a function within `.plt`
    * This function `jmp` to the address pointed by a corresponding `.got` entry \(it dereference the pointer\)
    * If this function has already been called, the address will be the absolute address of the function
    * If it is the first time, it'll be the address of the following instruction in the `.plt`
      * This instruction pushes some argument
      * And then calls the first function of the `.plt` which resolve the reference with the given arguments and then replace the entry in `.got` with the absolute address

### Libraries

* Static libs extensions are ::
  * `.a` for POSIX
  * `.lib` for windows \(don't confuse it with DLL import library files\)
* Dynamic / Shared libs extensions are :
  * `.so` for POSIX
  * `.dylib` forOSX
  * `.dll` for Windows

