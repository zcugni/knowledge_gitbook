# Executable creation

## Object file

* Object code refers to the corresponding binary of a source code
  * It's relocatable and needs to be linked before being an executable
  * Their relocatable because their symbol references aren't yet resolves, meaning that they aren't yet replaced by absolute addresses
* Assemblers and compilers can generate object files
* There's different format :
  * The most common one in Linux is the [Executable Linking Format \(ELF\)](https://zcugni.gitbook.io/notes/languages/general-concepts/elf-files)
  * On windows its the PE/COFF file format
* There's different types of relocatable object files :
  * `*.o` Generic \(used for static linking\)
  * `*.ko` Kernel \(loaded as kernel module, aka LKM, without the need to restart the system\)
  * `*.so` Shared object \(used for dynamic linking\)
* **Libraries** are collection of object files, that regroup functions used by many programs

## Linker

* Combine all the object and library files into one executable
  * It merges together the section of the same type \(likewise for segments\)
  * It resolves internal & external references of symbols to replace them by absolute address in a process called **relocation**

\*\*\*\*

* The linking process is platform dependent so check this for Linux \(i haven't yet done windows\)

### Static vs Dynamic linking

* There's 2 types linking :  static &  dynamic
* Statically linked executables are linked at the end of the compilation process, at link time
  * They contain all the code they need
  * Advantages :
    * You can be sure of the version of libraries used
    * They're self-contained
  * Disadvantages :
    * If you want to update a library, you need to recompile all binaries using it
    * They're quite big
    * Each process has its own copy of the libraries used
* Dynamically linked executables are linked at runtime \(just before the load i think\)
  * They depend on other object files to be complete
  * Advantages :
    * You'll have the latest version of libraries without recompilation of binaries
    * They're quite small in comparison to static ones
    * With virtual memory, one instance of a library can be shared to multiple processes
  * Disadvantages :
    * They have dependencies

## Assembler

* Transform assembly code into machine code \(aka binary\), creating object files

## Compiler

* See [Compilers](https://zcugni.gitbook.io/notes/languages/compilers)

## Interpreter

* An interpreter, like a compiler, translates high-level language into machine code \(binary\)
* Instead of reading the whole source code at once like a compiler, it reads it one line at a time \(and execute it\)
  * It stops as soon as an error occurs and report it

## Loader

* Used to load an executable file into memory, initialize the registers and execute it

## Pre-processor

* Often the first step of compilation
* Interpret pre-processor instructions such as includes and defines
  * By replacing includes with the desired content and macros by their value
* Removes comments, combined multi-line instruction and other clean-up stuff

## Makefile

{% hint style="info" %}
Add
{% endhint %}

## Sources

* [Tutorialspoint](https://www.tutorialspoint.com/compiler_design/index.htm)

