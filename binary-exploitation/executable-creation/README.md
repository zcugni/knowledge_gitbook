# Executable creation

## Object file

* Object code refers to the corresponding binary of a source code
  * It's relocatable and needs to be linked before being an executable
* Assemblers and compilers can generate object files
* There's different format, but the main one on Linux is the [Executable Linking Format \(ELF\)](https://zcugni.gitbook.io/notes/languages/general-concepts/elf-files)
* There are different types of relocatable object files:
  * `*.o` Generic \(used for static linking\)
  * `*.ko` Kernel \(loaded as kernel module, aka LKM, without the need to restart the system\)
  * `*.so` Shared object \(used for dynamic linking\)

## Linker

* Combine all the object and library files into one executable
* It resolve internal & external references of symbols to make them absolute in a process called **relocation**

### Libraries

* A library is a compiled binary \(but is not in itself an an executable as there's no `main()`\)
* It contains functions that can be used by multiple programs
* It should ship with it's header files which contain all functions prototypes
* Static libs extensions are ::
  * `.a` for POSIX
  * `.lib` for windows \(don't confuse it with DLL import library files\)
* Dynamic / Shared libs extensions are :
  * `.so` for POSIX
  * `.dylib` forOSX
  * `.dll` for Windows

### Static vs Dynamic linking

* Statically linked executables are linked at the end of the compilation process
  * They're self-contained
  * You can be sure of the version of the libraries used, but to update it you need to recompile the executable
  * The executable is quite big since it contains all the code it needs
  * Each process has its own copy of a library
* Dynamically linked executable are linked at runtime
  * They depend on other object files to be complete
  * You'll have the latest version of libraries automatically
  * The executable is quite small since a big part of the code comes from other files
  * One instance of a library can be shared to multiple processes
* Linux doesn't have preferred based image bases like Windows so `libc.so` won't be mapped at the same address for different processes

### Relocation

* 
## Assembler

* Transform assembly code into machine code \(aka binary\), creating object files

## Compiler

* See [Compilers](https://zcugni.gitbook.io/notes/languages/compilers)

## Interpreter

* An interpreter, like a compiler, translates high-level language into machine code \(binary\)
* Instead of reading the whole source code at once like a compiler, it reads it one line at a time \(and execute it\)
  * It stops as soon as an error occurs and report it

## Loader

* Used to load an executable file into memory, initialize the registers and execute it

## Pre-processor

* Often the first step of compilation
* Interpret pre-processor instructions such as includes and defines
  * By replacing includes with the desired content and macros by their value
* Removes comments, combined multi-line instruction and other clean-up stuff

## Makefile

{% hint style="info" %}
Add
{% endhint %}

## Sources

* [Tutorialspoint](https://www.tutorialspoint.com/compiler_design/index.htm)

