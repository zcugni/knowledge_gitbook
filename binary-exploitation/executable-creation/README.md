# Executable creation

## Object file

* Object code refers to the corresponding binary of a source code
  * It's relocatable and needs to be linked before being executable
* Assemblers and compilers can generate object files
* There's different format, but the main one is [Executable Linking Format \(ELF\)](https://zcugni.gitbook.io/notes/languages/general-concepts/elf-files)
* There are different types of relocatable object files:
  * `*.o` Generic \(used for static linking\)
  * `*.ko` Kernel \(loaded as kernel module, aka LKM, without the need to restart the system\)
  * `*.so` Shared object \(used for dynamic linking\)

## Static vs Dynamic linking

* Linking is the act of assembling multiple object files in one executable, and by so solving reference of symbols between those object files
* Statically linked executable contains all their code
  * You can be sure of the versions of the library
  * The executable is way bigger since it contains all the code it needs
  * Each process has its own copy of a library
* Dynamically linked ones must be linked at run time
  * You'll have the latest version of libraries
  * The executable is quite small since a big part of the code comes from other files
  * One instance of a library can be shared to multiple processes
* Linux doesn't have preferred based image bases like Windows so `libc.so` won't be mapped at the same address for different processes

## Assembler

* Transform assembly code into machine code \(aka binary\), creating object files

## Compiler

* See [Compilers](https://zcugni.gitbook.io/notes/languages/compilers)

## Interpreter

* An interpreter, like a compiler, translates high-level language into machine code \(binary\)
* Instead of reading the whole source code at once like a compiler, it reads it one line at a time \(and execute it\)
  * It stops as soon as an error occurs and report it

## Loader

* Used to load an executable file into memory, initialize the registers and execute it

## Pre-processor

* Often the first step of compilation
* Interpret pre-processor instructions such as includes and defines
  * By replacing includes with the desired content and macros by their value
* Removes comments, combined multi-line instruction and other clean-up stuff

## Makefile

{% hint style="info" %}
Add
{% endhint %}

## Sources

* [Tutorialspoint](https://www.tutorialspoint.com/compiler_design/index.htm)

