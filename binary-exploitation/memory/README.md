# Memory

## RAM vs Hard Drive vs Registers

* The RAM \(Random Access Memory\) is used by programs &  co
  * It's fast
  * It's volatile \(meaning its content disappear on power off\)
  * It's called "Random" because any part of the memory can be accessed regardless of where it's written
  * It's where the stack and the heap of a program will be
* Hard drive & co are the storage unit \(also called "m√©moire de masse" in french\)
  * It's slower
  * It's persistent \(doesn't disappear on power off\)
  * It's way bigger than the RAM
* Register are a special internal memory of processors, check this [page](https://zcugni.gitbook.io/notes/binary-exploitation/memory/registers) for details

## Segment of memory

* A compiled program memory is divided in 5 segments :
  * Text - The assembly code corresponding to the source code is stored here
    * Fixed size, read only
    * Sometimes called _code segment_
  * Data - For initialized global & static variables
    * Fixed size
  * BSS - For uninitialized global & static variables \(so that the needed space is reserved\)
    * Fixed size
    * They're initialized to 0
  * Heap - For dynamic memory allocation \(with for example `malloc`
    * The whole process is quite complex, check this [page](https://zcugni.gitbook.io/notes/binary-exploitation/memory/memory-allocation-linux-glibc)
    * Slower to access than the stack, but can contain more data
    * **Grows towards higher memory addresses**
  * Stack - For functions arguments, local variables & co
    * Because it doesn't need an allocation/freeing process, it's faster to access than the heap, but should contain smaller values
    * **Grows towards lower memory addresses**
    * LIFO structure \(Last In, First Out\)

## Stack layout

* Used to store information needed when a function is called
* For each call, a **stack frame** is placed on the stack, it's composed of :
  * The functions arguments in reverse order \(because of the LIFO structure
  * The return address
  * The base pointer
  * The local variables
* There's some differences on how the stack is used between 32-bits & 64-bits architecture
  * For example, 64-bits stores some arguments in registers and not on the stack
* This details the **process** of calling a new function on 32-bits, and how it affects the stack and three registers \(`eip`,`esp`,`ebp`\) :
  * Before the `call` instruction, the **arguments** are pushed in reverse order
  * During the `call` function, the **return address** is pushed to the stack and **eip** is changed to the first instruction of the new function
  * The new function does the following :
    * Push the current value of **ebp** \(the **saved frame pointer**\) to the stack
    * Set **ebp** to **esp**, so that it stores the address of the top of the stack at the beginning of the function
      * This makes it easier to access the arguments afterwards \(since **esp** will change during the course of the function\)
    * Reserve the space for the **local variables** on the stack by subtracting their length to **esp**
  * When returning the function :
    * Sets **esp** to **ebp**, so that the stack returns to the state it had when the new function was set up
    * Pop **esp** \(the **old ebp**\) to **ebp**, so it retrieve it's old value from before the function call
    * Pop **esp** \(the **return address**\) to **eip**, so the program can continue where it left of before the function call
* Beside those things, when a program is launched, the **environment variables** and the **executable name** are also pushed to the stack
  * During the program execution, they'll therefore be near the bottom
* Root privileges, sudos, etc can also change how the stack will look between 2 runs

## Sources

* Hacking : The Art of Exploitation by John Erickson
* [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
* [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)
* [blackblaze.com](https://www.backblaze.com/blog/whats-diff-ram-vs-storage/)

