# Registers

## Registers

* Processors have access to an internal memory called **registers** that are faster to access \(but way smaller\) than the RAM
* **Their number depends on the architecture**
  * Even if other architectures have more or less registers, some concept still exist, like the stack or instruction pointers
* On this page, i'll detail the IA-32 architecture
* It contains :
  * Ten 32-bit registers
  * Six 16-bit registers
  * These are divided in categories :
    * General, subdivided in :
      * Data
      * Pointer
      * Index
    * Control
    * Segment
* 32-bits register are called "extended ...", like **extended instruction pointer** `(eip)`
  * The lowest \(rightmost\) 16-bits part will be called the `ip`
  * For some registers, like `eax`, it can be further divided. The high part of `ax` is `ah` and the low part `al`

### **Data**

* 32-bit registers that can be divided in 16-bits or 8-bits parts if needed
* `eax` Primary accumulator, used in I/O and arithmetic
* `ebx` Base register, used in index addressing
* `ecx` Count Register, used in iterative operations
* `edx` Data register, used along `eax` for long values

### Pointer

* 32-bit registers \(but actually only the rightmost 16 bits is used if i understood correctly\)
* `eip` - Instruction Pointer / Program Counter 
  * Store the offset address of the **next instruction** to read
  * At the start of the program, it points to the start of the text segment
  * It increments it's value to the next instruction before the current one is executed \(so that if it's a `call`, the correct address will be saved as the next one, for example\)
  * Appended to  `cs` it gives the absolute address within the code segment
* `esp` - Stack pointer
  * Store the offset address of **the top of the stack**
  * Appended to `ss` it gives the absolute address within the stack segment
* `ebp` - Base Pointer / Local Base Pointer / Frame Pointer
  * Delimits **stack frame** \(areas on the stack for each given function\)
  * Makes it easier to access the **function arguments** by storing the address pointed by **`esp`** at the start of the new function
  * Since `esp` will change during the course of the function, it can't be use reliably for that
* These are heavily use to maneuver the stack, so read ... for more details

### Index

* 32-bit registers that can be divided in 16-bits parts if needed
* Used for string operations
* `esi` Source index
* `edi` Destination index

### Control

* The control register contains flag bits that are set during arithmetic operations and then used in condition \(like jumps\)
* Possible flag \(in, to my opinion, most to less useful order\) :
  * **Zero Flag \(ZF\)** - Indicates if the result of an operation equal 0
    *  Also called the **Equal Flag** because it's used in compare instruction to see if two values are equal \(by subtracting them\)
  * **Interrupt Flag \(IF\)** - Enable \(with 1\) or disable \(with 0\) external interrupts, like from a keyboard
  * **Trap Flag \(TF\)** - Allows to single-step forward instruction for debugging
  * **Sign Flag \(SF\)** - Indicates the sign of the result of an operation \(1 if negative\)
  * **Parity Flag \(PF\)** - If the number of 1-bits in the result is even, it's set to 0, otherwise 1
  * **Carry Flag \(CF\)** - Contains either :
    * The carry of 0 or 1 from the high-order \(leftmost\) bit after an operation
    * The contents of the last bit of a shift or rotate operation
  * **Overflow Flag \(OF\)** - Indicates the overflow of the high-order \(leftmost\) bit after a signed operation 
  * **Direction Flag \(DF\)** - Determines direction when working with strings, 0 for left-to-right, 1 for right-to-left
  * **Auxiliary Carry Flag \(AF\)** - Contains the carry from bit 3 to 4 after an operation
* In the register, this is the position of the flags :

| 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| :--- | :--- | :--- | :--- | :--- | :--- | :---: | :--- | :--- | :--- | :--- | :--- |
| O | D | I | T | S | Z |  | A |  | P |  | C |

* I don't know what the rest of the bits are used for

### Segment

* As said above, specific areas of a program's memory are reserved, those are called _segment_
* Six 16 bits registers keep the starting address of these segments :
  * `cs` for the **code segment**
  * `ss` for the **stack segment**
  * `ds` for the **data segment**
  * `es`, `fs` & `gs` for additional ones \(no idea what\)
* See [segment of memory](https://zcugni.gitbook.io/notes/binary-exploitation/memory#segment-of-memory) for more details

## Sources

* [Tutorialspoint](https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm)
* Hacking : The Art of Exploitation by John Erickson



