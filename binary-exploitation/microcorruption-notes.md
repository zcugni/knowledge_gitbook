# Microcorruption.com

## Introduction

This are my notes for the binary exploitation exercise of [microcorruption.com](https://microcorruption.com/) website.

## Architecture

* 16-bit architecture
* Little-endian
* Composed of 15 registers. 4 have special meanings :
  * R0 for `pc`
  * R1 for `sp`
  * R2 for `sr` \(Status Register\) - Flags used by conditional jumps
    * Z \(zero\) : It's set when it's value is 0003
    * N \(negative\)
    * C \(carry\)
  * R3 for `cg` \(Constant generation\)

## Value

* There's multiple way to specify or access a value, i'll detail them here :
  * Replace `y` by a number 
  * `ry` The value stored in `ry` \(the name `sp` or `pc` can also be used\)
  * `@ry` The value in memory pointed by `ry`
  * `@ry+` The value in memory pointed by `ry`, also increment `ry`
  * `#y` The actual value `y`
  * `y` The value in memory stored at offset `r0+y`
  * `y(ry)` Add the offset `y` to the address of `ry`
  * `$` The current value of `pc` \(you can do `$+y`\)
* There's also suffix :
  * `.b` Byte operation
  * `.w` Word operation

## Instructions

* I won't detail all instructions, only the most useful to me
* Look at .. for explanation of the common ones

### Single operand

* Some instructions are shortcuts for other longer combination \(which i call "actual instructions"\)
* Addresses can be function name when it makes sense

| Instruction | Actual instruction | Verbal Explanation |
| :--- | :--- | :--- |
| `clr <address>` | `mov #0,<address>` |  |
| `tst <address>` | `cmp #0,<address>` | Compares arg1 to 0 |
| `push <address>` |  |  |
| `pop <address>` | `mov @sp+,<address>` |  |
| `call <address>` |  |  |
|  `ret` | `mov @sp+,pc` |  |
| `inc <address>` | `add #1,<address>` | Increment |
| `incd <address>` | `add #2,<address>` | Double Increment |
| `dec <address>` | `sub #1,<address>` | Decrement |
| `decd <address>` | `sub #2,<address>` | Double Decrement |
| `swpb` |  | Swap bytes \(for example, swap 007d to 7d00\) |

### Double operand

* General syntax : `<intstruction_name> <source>,<destination>`
* `agr1` & `agr2` can be values or addresses where it makes sense
* `mov arg1,arg2`
* `add arg1,arg2`
* `sub arg1,arg2`
* `cpm arg1,arg2`
* `and arg1,arg2`
* In addition to the jumps given at ..., there's :
  * `jlo` Lower
  * `jhs` Same or higher
  * `jn` Negative
  * `jge` Greater or equal
  * `jl` Less

## Interrupts

* There's a bunch of special interrupts from the exercises of microcorruption.com
* These are special-purpose functions of the device
* To use them, call the `INT` function, but first, push the interrupt code to the stack \(for example 0x7d\)
* An explanation of all interrupts is given by the game manual

## Disassemble

* Some functions/instructions might not be written into memory when you launch a program \(they can be written from a loop afterwards for example\)
* In this case, they won't be initially disassemble by your debugger, you need to do it explicitly afterwards \(with an online tool for example\)

## Sources

* [microcorruption.com](https://microcorruption.com/)
* [razvioverflow](https://razvioverflow.github.io/microcorruption/)
* Wikipedia's [page ](https://en.wikipedia.org/wiki/TI_MSP430)about the TI MSP430
* [jaimelightfoot.com](https://jaimelightfoot.com/blog/)



