# Hacking : The Art of Exploitation Notes

## PLT & GOT

* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## Reseau

* socket is a standard way to perform network communication through the OS. A socket can be thought of as an endpoint to a connection, like a socket on an operator’s switchboard. But these sockets are just a programmer’s abstraction that takes care of all the nitty-gritty details of the OSI model described above.
  * There are several different types of sockets that determine the structure of the transport layer \(4\). The most common types are stream sockets and datagram sockets.
  * Stream sockets provide reliable two-way communication similar to when you call someone on the phone.
  * Stream sockets use a standard communication protocol called Transmission Control Protocol \(TCP\),
  * Another common type of socket is a datagram socket. Communicating with a datagram socket is more like mailing a letter than making a phone call.
  * Datagram sockets use another standard protocol called UDP instead of TCP on the transport layer
* copy functions 0x421 Socket Functions
  * When a socket is created with the socket\(\) function, the domain, type, and protocol of the socket must be specified. The domain refers to the protocol family of the socket.
  * The final argument for the socket\(\) function is the protocol, which should almost always be 0. The specification allows for multiple protocols within a protocol family, so this argument is used to select one of the protocols from the family. In practice, however, most protocol families only have one protocol, which means this should usually be set for 0; the first and only protocol in the enumeration of the family
* 0x422 Socket Addresses
  * The possible address families are also defined in bits/socket.h; they usually translate directly to the corresponding protocol families.
  * The macro for SOCKADDR\_COMMON is defined in the included bits/sockaddr.h file, which basically translates to an unsigned short int. This value defines the address family of the address, and the rest of the structure is saved for address data.
  * address family strzct are of the same size
* 0x423 Network Byte Order
  * 0x424 Internet Address Conversion
* By default, webservers run on port 80, which is listed along with many other default ports in /etc/services.
* An Ethernet header is 14 bytes in size and contains the source and destination MAC addresses for this Ethernet packet.
  * There are four different types of ARP messages, but the two most important types are ARP request messages and ARP reply messages. Any packet’s Ethernet header includes a type value that describes the packet. This type is used to specify whether the packet is an ARP-type message or an IP packet.
  * sender’s IP address and MAC address and basically says, “Hey, who has this IP? If it’s you, please respond and tell me your MAC address.” An ARP reply is the corresponding response that is sent to the requester’s MAC address \(and IP address\) saying, “This is my MAC address, and I have this IP address.”
* The IP header for packets in this layer is 20 bytes in size and consists of various fields and bitflags as defined in RFC 791.
  * Similar to the Ethernet header, the IP header also has a protocol field to describe the type of data in the packet and the source and destination addresses for routing. In addition, the header carries a checksum, to help detect transmission errors, and fields to deal with packet fragmentation
  * Add img
  * ICMP packets are used for messaging and diagnostics.
    * there’s no guarantee that an IP packet will actually reach its final destination. If there’s a problem, an ICMP packet is sent back to notify the sender of the problem.
    * ICMP is also commonly used to test for connectivity. ICMP Echo Request and Echo Reply messages are used by a utility called ping. If one host wants to test whether it can route traffic to another host, it pings the remote host by sending an ICMP Echo Request. Upon receipt of the ICMP Echo Request, the remote host sends back an ICMP Echo Reply. These messages can be used to determine the connection latency between the two hosts. However, it is important to remember that ICMP and IP are both connectionless; all this protocol layer really cares about is getting the packet to its destination address.
  * Sometimes a network link will have a limitation on packet size, disallowing the transfer of large packets. IP can deal with this situation by fragmenting packets,
    * The packet is broken up into smaller packet fragments that can pass through the network link, IP headers are put on each fragment, and they’re sent off. Each fragment has a different fragment offset value, which is stored in the header. When the destination receives these fragments, the offset values are used to reassemble the original IP packet.
  * Stream sockets use TCP/IP connections.
  * Ad tco flags
    * The TCP header is specified in RFC 793
    * The sequence number and acknowledgment number are used to maintain state. The SYN and ACK flags are used together to open connections in a three-step handshaking process. When a client wants to open a connection with a server, a packet with the SYN flag on, but the ACK flag off, is sent to the server. The server then responds with a packet that has both the SYN and ACK flags turned on. To complete the connection, the client sends back a packet with the SYN flag off but the ACK flag on. After that, every packet in the connection will have the ACK flag turned on and the SYN flag turned off.
    * Sequence numbers allow TCP to put unordered packets back into order, to determine whether packets are missing, and to prevent mixing up packets from other connections. When a connection is initiated, each side generates an initial sequence number. This number is communicated to the other side in the first two SYN packets of the connection handshake. Then, with each packet that is sent, the sequence number is incremented by the number of bytes found in the data portion of the packet. This sequence number is included in the TCP packet header. In addition, each TCP header has an acknowledgment number, which is simply the other side’s sequence number plus one.
  * The UDP header, defined in RFC 768, is relatively tiny. It only contains four 16-bit values in this order: source port, destination port, length, and checksum.
  * On the data-link layer lies the distinction between switched and unswitched networks. On an unswitched network, Ethernet packets pass through every device on the network, expecting each system device to only look at the packets sent to its destination address. However, it’s fairly trivial to set a device to promiscuous mode, which causes it to look at all packets, regardless of the destination address. Most packet-capturing programs, such as tcpdump, drop the device they are listening to into promiscuous mode by default. Promiscuous mode can be set using ifconfig, as seen in the following output.
  * tcpdump is a wonderful, general-purpose packet sniffer, but there are specialized sniffing tools designed specifically to search for usernames and passwords. One notable example is Dug Song’s program, dsniff, which is smart enough to parse out data that looks important.
  * It is possible to access the network at lower layers using raw sockets. At this lower layer, all the details are exposed and must be handled explicitly by the programmer. Raw sockets are specified by using SOCK\_RAW as the type. In this case, the protocol matters since there are multiple options. The protocol can be IPPROTO\_TCP, IPPROTO\_UDP, or IPPROTO\_ICMP. The following example is a TCP sniffing program using raw sockets.
    * When compiled, the program needs to be run as root, because the use of raw sockets requires root acces
    * Another big problem with raw sockets is that they are notoriously inconsistent between systems. Raw socket code for Linux most likely won’t work on BSD or Solaris
    * A standardized programming library called libpcap can be used to smooth out the inconsistencies of raw sockets. The functions in this library still use raw sockets to do their magic, but the library knows how to correctly work with raw sockets on multiple architectures. Both tcpdump and dsniff use libpcap, which allows them to compile with relative ease on any platform.
* When this program is compiled, the pcap libraries must be linked. This can be done using the -l flag with GCC
* The compiler padding, as mentioned earlier, will align this structure on a 4-byte boundary by padding the rest of the structure. IP headers are always 20 bytes.
* You can put if in struct in C ?



* In a switched network environment, packets are only sent to the port they are destined for, according to their destination MAC addresses. This requires more intelligent hardware that can create and maintain a table associating MAC addresses with certain ports, depending on which device is connected to each port,
* There’s no provision in these protocols to ensure that the source address in a packet really is the address of the source machine. The act of forging a source address in a packet is known as spoofing
* First, when an ARP reply comes in with an IP address that already exists in the ARP cache, the receiving system will overwrite the prior MAC address information with the new information found in the reply \(unless that entry in the ARP cache was explicitly marked as permanent\). Second, no state information about the ARP traffic is kept, since this would require additional memory and would complicate a protocol that is meant to be simple. This means systems will accept an ARP reply even if they didn’t send out an ARP request.
* These three details, when exploited properly, allow an attacker to sniff network traffic on a switched network using a technique known as ARP redirection. The attacker sends spoofed ARP replies to certain devices that cause the ARP cache entries to be overwritten with the attacker’s data. This technique is called ARP cache poisoning. In order to sniff network traffic between two points, A and B, the attacker needs to poison the ARP cache of A to cause A to believe that B’s IP address is at the attacker’s MAC address, and also poison the ARP cache of B to cause B to believe that A’s IP address is also at the attacker’s MAC address. Then the attacker’s machine simply needs to forward these packets to their appropriate final destinations. After that, all of the traffic between A and B still gets delivered, but it all flows through the attacker’s machine,
  * Due to timeout values, the victim machines will periodically send out real ARP requests and receive real ARP replies in response. In order to maintain the redirection attack, the attacker must keep the victim machine’s ARP caches poisoned. A simple way to accomplish this is to send spoofed ARP replies to both A and B at a constant interval—for example, every 10 seconds.
* you cando that with the default gateway also
  * These spoofed ARP packets can be injected using a command-line packet injection tool called Nemesis. Nemesis was originally a suite of tools written by Mark Grimes, but in the most recent version 1.4, all functionality has been rolled up into a single utility by the new maintainer and developer, Jeff Nathan
* Nemesis uses a C library called libnet to craft spoofed packets and inject them. Similar to libpcap, this library uses raw sockets and evens out the inconsistencies between platforms with a standardized interface. libnet also provides several convenient functions for dealing with network packets, such as checksum generation



* Dug Song provides a program called arpspoof, included with dsniff, that performs the ARP redirection attack



* In C, typedef is used to alias a data type with a symbol.



* There are two general forms of DoS attacks: those that crash services and those that flood services.
  * Denial of Service attacks that crash services are actually more similar to program exploits than network-based exploits. Often, these attacks are dependent on a poor implementation by a specific vendor. A buffer overflow exploit gone wrong will usually just crash the target program instead of directing the execution flow to the injected shellcode. If this program happens to be on a server, then no one else can access that server after it has crashed. Crashing DoS attacks like this are closely tied to a certain program and a certain version. Since the operating system handles the network stack, crashes in this code will take down the kernel, denying service to the entire machine.
  * A SYN flood tries to exhaust states in the TCP/IP stack. Since TCP maintains “reliable” connections, each connection needs to be tracked somewhere. The TCP/IP stack in the kernel handles this, but it has a finite table that can only track so many incoming connections. A SYN flood uses spoofing to take advantage of this limitation. The attacker floods the victim’s system with many SYN packets, using a spoofed nonexistent source address. Since a SYN packet is used to initiate a TCP connection, the victim’s machine will send a SYN/ACK packet to the spoofed address in response and wait for the expected ACK response. Each of these waiting, half-open connections goes into a backlog queue that has limited space. Since the spoofed source addresses don’t actually exist, the ACK responses needed to remove these entries from the queue and complete the connections never come. Instead, each half-open connection must time out, which takes a relatively long time. As long as the attacker continues to flood the victim’s system with spoofed SYN packets, the victim’s backlog queue will remain full, making it nearly impossible for real SYN packets to get to the system and initiate valid TCP/IP connections.
    * Some operating systems \(for example, Linux\) use a technique called syncookies to try to prevent SYN flood attacks. The TCP stack using syncookies adjusts the initial acknowledgment number for the responding SYN/ACK packet using a value based on host details and time \(to prevent replay attacks\). 256 0x400 The TCP connections don’t actually become active until the final ACK packet for the TCP handshake is checked. If the sequence number doesn’t match or the ACK never arrives, a connection is never created. This helps prevent spoofed connection attempts, since the ACK packet requires information to be sent to the source address of the initial SYN packet.
  * According to the specification for ICMP, ICMP echo messages can only have 216, or 65,536, bytes of data in the data part of the packet. The data portion of ICMP packets is commonly overlooked, since the important information is in the header. Several operating systems crashed if they were sent ICMP echo messages that exceeded the size specified. An ICMP echo message of this gargantuan size became affectionately known as “The Ping of Death.” It was a very simple hack exploiting a vulnerability that existed because no one ever considered this possibility.
    * Modern systems are all patched against this vulnerability.
    * However, history tends to repeat itself. Even though oversized ICMP packets won’t crash computers anymore, new technologies sometimes suffer from similar problems
  * Teardrop exploited another weakness in several vendors’ implementations of IP fragmentation reassembly. Usually, when a packet is fragmented, the offsets stored in the header will line up to reconstruct the original packet with no overlap. The teardrop attack sent packet fragments with overlapping offsets, which caused implementations that didn’t check for this irregular condition to inevitably crash
  * Flooding DoS attacks don’t try to necessarily crash a service or resource, but instead try to overload it so it can’t respond. Similar attacks can tie up other resources, such as CPU cycles and system processes, but a flooding attack specifically tries to tie up a network resource. The simplest form of flooding is just a ping flood. The goal is to use up the victim’s bandwidth so that legitimate traffic can’t get through. The attacker sends many large ping packets to the victim, which eat away at the bandwidth of the victim’s network connection. There’s nothing really clever about this attack—it’s just a battle of bandwidth. An attacker with greater bandwidth than a victim can send more data than the victim can receive and therefore deny other legitimate traffic from getting to the victim.
  * There are actually some clever ways to perform a ping flood without using massive amounts of bandwidth. An amplification attack uses spoofing and broadcast addressing to amplify a single stream of packets by a hundred-fold. First, a target amplification system must be found. This is a network that allows communication to the broadcast address and has a relatively high number of active hosts. Then the attacker sends large ICMP echo request packets to the broadcast address of the amplification network, with a spoofed source address of the victim’s system. The amplifier will broadcast these packets to all the hosts on the amplification network, which will then send corresponding ICMP echo reply packets to the spoofed source address \(i.e., to the victim’s machine\). This amplification of traffic allows the attacker to send a relatively small stream of ICMP echo request packets out, while the victim gets swamped with up to a couple hundred times as many ICMP echo reply packets. This attack can be done with both ICMP packets and UDP echo packets. These techniques are known as smurf and fraggle attacks, respectively.
  * A distributed DoS \(DDoS\) attack is a distributed version of a flooding DoS attack. Since bandwidth consumption is the goal of a flooding DoS attack, the more bandwidth the attacker is able to work with, the more damage they can do. In a DDoS attack, the attacker first compromises a number of other hosts and installs daemons on them. Systems installed with such software are commonly referred to as bots and make up what is known as a botnet. These bots wait patiently until the attacker picks a victim and decides to attack. The attacker uses some sort of a controlling program, and all of the bots simultaneously attack the victim with some form of flooding DoS attack. Not only does the great number of distributed hosts multiply the effect of the flooding, this also makes tracing the attack source much more difficult.
  * TCP/IP hijacking is a clever technique that uses spoofed packets to take over a connection between a victim and a host machine. This technique is exceptionally useful when the victim uses a one-time password to connect to the host machine. A one-time password can be used to authenticate once and only once, which means that sniffing the authentication is useless for the attacker. To carry out a TCP/IP hijacking attack, the attacker must be on the same network as the victim. By sniffing the local network segment, all of the details of open TCP connections can be pulled from the headers. As we have seen, each TCP packet contains a sequence number in its header. This sequence number is incremented with each packet sent to ensure that packets are received in the correct order. While sniffing, the attacker has access to the sequence numbers for a connection between a victim \(system A in the following illustration\) and a host machine \(system B\). Then the attacker sends a spoofed packet from the victim’s IP address to the host machine, using the sniffed sequence number to provide the proper acknowledgment number, as shown here.The host machine will receive the spoofed packet with the correct acknowledgment number and will have no reason to believe it didn’t come from the victim machine.
  * A very simple form of TCP/IP hijacking involves injecting an authentic-looking reset \(RST\) packet. If the source is spoofed and the acknowledgment number is correct, the receiving side will believe that the source actually sent the reset packet, and the connection will be reset.
  * The spoofed packet doesn’t need to be an RST packet. This attack becomes more interesting when the spoof packet contains data. The host machine receives the spoofed packet, increments the sequence number, and responds to the victim’s IP. Since the victim’s machine doesn’t know about the spoofed packet, the host machine’s response has an incorrect sequence number, so the victim ignores that response packet. And since the victim’s machine ignored the host machine’s response packet, the victim’s sequence number count is off. Therefore, any packet the victim tries to send to the host machine will have an incorrect sequence number as well, causing the host machine to ignore it. In this case, both legitimate sides of the connection have incorrect sequence numbers, resulting in a desynchronized state. And since the attacker sent out the first spoofed packet that caused all this chaos, it can keep track of sequence numbers and continue spoofing packets from the victim’s IP address to the host machine. This lets the attacker continue communicating with the host machine while the victim’s connection hangs.



* Idle scanning is a way to scan a target using spoofed packets from an idle host, by observing changes in the idle host. The attacker needs to find a usable idle host that is not sending or receiving any other network traffic and that has a TCP implementation that produces predictable IP IDs that change by a known increment with each packet. IP IDs are meant to be unique per packet per session, and they are commonly incremented by a fixed amount. Predictable IP IDs have never really been considered a security risk, and idle scanning takes advantage of this misconception. Newer operating systems, such as the recent Linux kernel, OpenBSD, and Windows Vista, randomize the IP ID, but older operating systems and hardware \(such as printers\) typically do not. First, the attacker gets the current IP ID of the idle host by contacting it with a SYN packet or an unsolicited SYN/ACK packet and observing the IP ID of the response. By repeating this process a few more times, the increment applied to the IP ID with each packet can be determined. Then, the attacker sends a spoofed SYN packet with the idle host’s IP address to a port on the target machine. One of two things will happen, depending on whether that port on the victim machine is listening: 󰀀 If that port is listening, a SYN/ACK packet will be sent back to the idle host. But since the idle host didn’t actually send out the initial SYN packet, this response appears to be unsolicited to the idle host, and it responds by sending back an RST packet. 󰀀 If that port isn’t listening, the target machine doesn’t send a SYN/ACK packet back to the idle host, so the idle host doesn’t respond. 266 0x400 At this point, the attacker contacts the idle host again to determine how much the IP ID has incremented. If it has only incremented by one interval, no other packets were sent out by the idle host between the two checks. This implies that the port on the target machine is closed. If the IP ID has incremented by two intervals, one packet, presumably an RST packet, was sent out by the idle machine between the checks. This implies that the port on the target machine is open.



* To exploit the vulnerability in the tinyweb.c program, we just need to send packets that will strategically overwrite the return address. First, we need to know the offset from the start of a buffer we control to the stored return address. Using GDB, we can analyze the compiled program to find this; however, there are some subtle details that can cause tricky problems. For example, the program requires root privileges, so the debugger must be run as root. But using sudo or running with root’s environment will change the stack, meaning the addresses seen in the debugger’s run of the binary won’t match the addresses when it’s running normally. There are other slight differences that can shift memory around in the debugger like this, creating inconsistencies that can be maddening to track down. According to the debugger, everything will look like it should work; however, the exploit fails when run outside the debugger, since the addresses are different. One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.





## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

