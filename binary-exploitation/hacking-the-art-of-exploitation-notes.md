# Hacking : The Art of Exploitation Notes

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* BASH’s for loop can actually be used to send each of these lines to an echo command, with command-line options to recognize hex expansion and to suppress adding a newline character to the end. : `-en`

\`\`

* Use env var if the buffer is too small for shellcode
  * env var near bottom of stack
  * A breakpoint is set at the beginning of main\(\), and the program is run. This will set up memory for the program, but it will stop before anything happens. Now we can examine memory down near the bottom of the stack.
  * In C’s standard library there is a function called getenv\(\), which accepts the name of an environment variable as its only argument and returns that variable’s memory address.



* Notice that the salt value is always at the beginning of the hash. When a user logs in and enters a password, the system looks up the encrypted password 154 0x300 for that user. Using the salt value from the stored encrypted password, the system uses the same one-way hashing algorithm to encrypt whatever text the user typed as the password
  * ```text
    reader@hacking:~/booksrc $ perl -e 'print crypt("password", "AA"). "\n"'
    AA6tQYSfGxd/A
    reader@hacking:~/booksrc $ perl -e 'print crypt("password", "XX"). "\n"'
    XXq2wKiyI43A2
    ```
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program
* **cat -**
* 


* In binary programs compiled with the GNU C compiler, special table sections called .dtors and .ctors are made for destructors and constructors, respectively.
  * Constructor functions are executed before the main\(\) function is executed, and destructor functions are executed just before the main\(\) function exits with an exit system call.
  * A function can be declared as a destructor function by defining the destructor attribute
  * `static void cleanup(void) __attribute__ ((destructor));`
  * In the preceding code sample, the cleanup\(\) function is defined with the destructor attribute, so the function is automatically called when the main\(\) function exits
  * This behavior of automatically executing a function on exit is controlled by the .dtors table section of the binary. This section is an array of 32-bit addresses terminated by a NULL address. The array always begins with 0xffffffff and ends with the NULL address of 0x00000000. Between these two are the addresses of all the functions that have been declared with the destructor attribute.
  * The nm command can be used to find the address of the cleanup\(\) function, and objdump can be used to examine the sections of the binary.
  * the .dtors section is that it is writable
  * the .dtors section is that it is included in all binaries compiled with the GNU C compiler, regardless of whether any functions were declared with the destructor attribute



* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). Exploitation 191 This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add





```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

## GDB 

* Test if `set disassembly intel` works
  * Write it in the `~./.gdbinit` file
  * Test if you can define the hook-stop there too
* If the c source code was compiled with `gcc` with the  `-d` options, `gdb` can have access to the source code with `list`
  * i guess it's only the case when having acces to the source code, but you can examine a variable with `x/xw var`
    * And retrieve the address of a variable with `&var`
* Verify that the shorthand of the `info` commands actually work
*  `bt` Shows the stack backtrace
  * The backtrace also shows the nested function calls by looking at records kept on the stack. Each time a function is called, a record called a stack frame is put on the stack. Each line in the backtrace corresponds to a stack frame. Each stack frame also contains the local variables for that context. The local variables contained in each stack frame can be shown in GDB by adding the word full to the backtrace command.



