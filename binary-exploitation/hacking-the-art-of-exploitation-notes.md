# Hacking : The Art of Exploitation Notes

## RFC notes

* The "three-way handshake" is the procedure used to establish a

    connection.  This procedure normally is initiated by one TCP and

    responded to by another TCP.  The procedure also works if two TCP

    simultaneously initiate the procedure.  When simultaneous attempt

    occurs, each TCP receives a "SYN" segment which carries no

    acknowledgment after it has sent a "SYN".  Of course, the arrival of

    an old duplicate "SYN" segment can potentially make it appear, to the

    recipient, that a simultaneous connection initiation is in progress.

    Proper use of "reset" segments can disambiguate these cases.

  * Several examples of connection initiation follow.  Although these

      examples do not show connection synchronization using data-carrying

      segments, this is perfectly legitimate, so long as the receiving TCP

      doesn't deliver the data to the user until it is clear the data is

      valid \(i.e., the data must be buffered at the receiver until the

      connection reaches the ESTABLISHED state\).  The three-way handshake

      reduces the possibility of false connections.



```text
 1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

*  Note that the

    sequence number of the segment in line 5 is the same as in line 4

    because the ACK does not occupy sequence number space \(if it did, we

    would wind up ACKing ACK's!\).



* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* an rst contains the seq number it reference, not the one it should have by now
* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* There are three groups of states:
  * 1.  If the connection does not exist \(CLOSED\) then a reset is sent

        in response to any incoming segment except another reset.  In

        particular, SYNs addressed to a non-existent connection are rejected

        by this means.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the CLOSED state.

  * 2.  If the connection is in any non-synchronized state \(LISTEN,

        SYN-SENT, SYN-RECEIVED\), and the incoming segment acknowledges

        something not yet sent \(the segment carries an unacceptable ACK\), or

        if an incoming segment has a security level or compartment which

        does not exactly match the level and compartment requested for the

        connection, a reset is sent.

    * If our SYN has not been acknowledged and the precedence level of the

          incoming segment is higher than the precedence level requested then

          either raise the local precedence level \(if allowed by the user and

          the system\) or send a reset; or if the precedence level of the

          incoming segment is lower than the precedence level requested then

          continue as if the precedence matched exactly \(if the remote TCP

          cannot raise the precedence level to match ours this will be

          detected in the next segment it sends, and the connection will be

          terminated then\).  If our SYN has been acknowledged \(perhaps in this

          incoming segment\) the precedence level of the incoming segment must

          match the local precedence level exactly, if it does not a reset

          must be sent.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the same state.

  * If the connection is in a synchronized state \(ESTABLISHED,

        FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\),

        any unacceptable segment \(out of window sequence number or

        unacceptible acknowledgment number\) must elicit only an empty

        acknowledgment segment containing the current send-sequence number

        and an acknowledgment indicating the next sequence number expected

        to be received, and the connection remains in the same state.

    * If an incoming segment has a security level, or compartment, or

          precedence which does not exactly match the level, and compartment,

          and precedence requested for the connection,a reset is sent and

          connection goes to the CLOSED state.  The reset takes its sequence

          number from the ACK field of the incoming segment.
*  In all states except SYN-SENT, all reset \(RST\) segments are validated

    by checking their SEQ-fields.  A reset is valid if its sequence number

    is in the window.  In the SYN-SENT state \(a RST received in response

    to an initial SYN\), the RST is acceptable if the ACK field

    acknowledges the SYN.

  * The receiver of a RST first validates it, then changes state.  If the

      receiver was in the LISTEN state, it ignores it.  If the receiver was

      in SYN-RECEIVED state and had previously been in the LISTEN state,

      then the receiver returns to the LISTEN state, otherwise the receiver

      aborts the connection and goes to the CLOSED state.  If the receiver

      was in any other state, it aborts the connection and advises the user

      and goes to the CLOSED state.



* CLOSE is an operation meaning "I have no more data to send."
* The user who CLOSEs may continue to RECEIVE

    until he is told that the other side has CLOSED also

* A TCP will reliably deliver all

    buffers SENT before the connection was CLOSED

* There are essentially three cases:
  * The user initiates by telling the TCP to CLOSE the connection
    * In this case, a FIN segment can be constructed and placed on the

          outgoing segment queue.  No further SENDs from the user will be

          accepted by the TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs

          are allowed in this state.  All segments preceding and including FIN

          will be retransmitted until acknowledged.  When the other TCP has

          both acknowledged the FIN and sent a FIN of its own, the first TCP

          can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not

          send its own FIN until its user has CLOSED the connection also.
  * 2\) The remote TCP initiates by sending a FIN control signal
    * If an unsolicited FIN arrives from the network, the receiving TCP

          can ACK it and tell the user that the connection is closing.  The

          user will respond with a CLOSE, upon which the TCP can send a FIN to

          the other TCP after sending any remaining data.  The TCP then waits

          until its own FIN is acknowledged whereupon it deletes the

          connection.  If an ACK is not forthcoming, after the user timeout

          the connection is aborted and the user is told.
  * Both users CLOSE simultaneously
    * A simultaneous CLOSE by users at both ends of a connection causes

          FIN segments to be exchanged.  When all segments preceding the FINs

          have been processed and acknowledged, each TCP can ACK the FIN it

          has received.  Both will, upon receiving these ACKs, delete the

          connection.



* Read 3.7 Data Communication
* 
## PLT & GOT

* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

