# Hacking : The Art of Exploitation Notes

## RFC notes



* TCP should be able to operate above a

    wide spectrum of communication systems ranging from hard-wired

    connections to packet-switched or circuit-switched networks.

* The TCP interfaces on one side to user or application processes and on

    the other side to a lower level protocol such as Internet Protocol.

  * Although

      considerable freedom is permitted to TCP implementors to design

      interfaces which are appropriate to a particular operating system

      environment, a minimum functionality is required at the TCP/user

      interface for any valid implementation.

  *  The interface between TCP and lower level protocol is essentially

      unspecified except that it is assumed there is a mechanism whereby the

      two levels can asynchronously pass information to each other.

* General axes :
  * Basic Data Transfer
    * The TCP is able to transfer a continuous stream of octets in each

          direction between its users by packaging some number of octets into

          segments for transmission through the internet system
  * Reliability
    * The TCP must recover from data that is damaged, lost, duplicated, or

          delivered out of order by the internet communication system.  This

          is achieved by assigning a sequence number to each octet

          transmitted, and requiring a positive acknowledgment \(ACK\) from the

          receiving TCP.  If the ACK is not received within a timeout

          interval, the data is retransmitted.  At the receiver, the sequence

          numbers are used to correctly order segments that may be received

          out of order and to eliminate duplicates.  Damage is handled by

          adding a checksum to each segment transmitted, checking it at the

          receiver, and discarding damaged segments.
  * Flow Control
    * TCP provides a means for the receiver to govern the amount of data

          sent by the sender.  This is achieved by returning a "window" with

          every ACK indicating a range of acceptable sequence numbers beyond

          the last segment successfully received.  The window indicates an

          allowed number of octets that the sender may transmit before

          receiving further permission.
  * Multiplexing
    * To allow for many processes within a single Host to use TCP

          communication facilities simultaneously, the TCP provides a set of

          addresses or ports within each host.  Concatenated with the network

          and host addresses from the internet communication layer, this forms

          a socket.  A pair of sockets uniquely identifies each connection.

          That is, a socket may be simultaneously used in multiple

          connections.
  * Connections
    * The reliability and flow control mechanisms described above require

          that TCPs initialize and maintain certain status information for

          each data stream.  The combination of this information, including

          sockets, sequence numbers, and window sizes, is called a connection.

          Each connection is uniquely specified by a pair of sockets

          identifying its two sides.



          When two processes wish to communicate, their TCP's must first

          establish a connection \(initialize the status information on each

          side\).  When their communication is complete, the connection is

          terminated or closed to free the resources for other uses.
  * Precedence and Security
    * The users of TCP may indicate the security and precedence of their

          communication.  Provision is made for default values to be used when

          these features are not needed.
* The TCP/user interface provides for calls made by the user on the TCP

    to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to obtain

    STATUS about a connection.  These calls are like other calls from user

    programs on the operating system, for example, the calls to open, read

    from, and close a file.

* Transmission is made reliable via the use of sequence numbers and

    acknowledgments.  Conceptually, each octet of data is assigned a

    sequence number.  The sequence number of the first octet of data in a

    segment is transmitted with that segment and is called the segment

    sequence number.  Segments also carry an acknowledgment number which

    is the sequence number of the next expected data octet of

    transmissions in the reverse direction.  When the TCP transmits a

    segment containing data, it puts a copy on a retransmission queue and

    starts a timer; when the acknowledgment for that data is received, the

    segment is deleted from the queue.  If the acknowledgment is not

    received before the timer runs out, the segment is retransmitted.

  * An acknowledgment by TCP does not guarantee that the data has been

      delivered to the end user, but only that the receiving TCP has taken

      the responsibility to do so.

  * To govern the flow of data between TCPs, a flow control mechanism is

      employed.  The receiving TCP reports a "window" to the sending TCP.

      This window specifies the number of octets, starting with the

      acknowledgment number, that the receiving TCP is currently prepared to

      receive.

* A connection is specified in the OPEN call by the local port and

    foreign socket arguments.  In return, the TCP supplies a \(short\) local   connection name by which the user refers to the connection in

    subsequent calls.

  * There are several things that must be remembered

      about a connection.  To store this information we imagine that there

      is a data structure called a Transmission Control Block \(TCB\)

  * The OPEN call also specifies

      whether the connection establishment is to be actively pursued, or to

      be passively waited for.

    * A passive OPEN request means that the process wants to accept incoming

        connection requests rather than attempting to initiate a connection.

        Often the process requesting a passive OPEN will accept a connection

        request from any caller.  In this case a foreign socket of all zeros

        is used to denote an unspecified socket.  Unspecified foreign sockets

        are allowed only on passive OPENs.

    * There are two principal cases for matching the sockets in the local

        passive OPENs and an foreign active OPENs.  In the first case, the

        local passive OPENs has fully specified the foreign socket.  In this

        case, the match must be exact.  In the second case, the local passive

        OPENs has left the foreign socket unspecified.  In this case, any

        foreign socket is acceptable as long as the local sockets match.

        Other possibilities include partially restricted matches.

    * If there are several pending passive OPENs \(recorded in TCBs\) with the

        same local socket, an foreign active OPEN will be matched to a TCB

        with the specific foreign socket in the foreign active OPEN, if such a

        TCB exists, before selecting a TCB with an unspecified foreign socket.

    * the procedures to establish connections utilize the synchronize \(SYN\)

        control flag and involves an exchange of three messages.  This

        exchange has been termed a three-way hand shake \[3\].

      * A connection is initiated by the rendezvous of an arriving segment

          containing a SYN and a waiting TCB entry each created by a user OPEN

          command.  The matching of local and foreign sockets determines when a

          connection has been initiated.  The connection becomes "established"

          when sequence numbers have been synchronized in both directions.

    * The clearing of a connection also involves the exchange of segments,

        in this case carrying the FIN control flag.

* The concept of a

    well-known socket is part of the TCP specification, but the assignment

    of sockets to services is outside this specification.

  * two processes which issue active OPENs to each

      other at the same time will be correctly connected.

* The data that flows on a connection may be thought of as a stream of

    octets.  The sending user indicates in each SEND call whether the data

    in that call \(and any preceeding calls\) should be immediately pushed

    through to the receiving user by the setting of the PUSH flag.

  * A sending TCP is allowed to collect data from the sending user and to

      send that data in segments at its own convenience, until the push

      function is signaled, then it must send all unsent data.  When a

      receiving TCP sees the PUSH flag, it must not wait for more data from

      the sending TCP before passing the data to the receiving process

  * There is a coupling between the push function and the use of buffers

      of data that cross the TCP/user interface.  Each time a PUSH flag is

      associated with data placed into the receiving user's buffer, the

      buffer is returned to the user for processing even if the buffer is

      not filled.  If data arrives that fills the user's buffer before a

      PUSH is seen, the data is passed to the user in buffer size units.

  * TCP also provides a means to communicate to the receiver of data that

      at some point further along in the data stream than the receiver is     currently reading there is urgent data.  TCP does not attempt to

      define what the user specifically does upon being notified of pending

      urgent data, but the general notion is that the receiving process will

      take action to process the urgent data quickly.

* TCP implementations will follow a general principle of robustness:  be

    conservative in what you do, be liberal in what you accept from

    others.

* headers :
  * Source Port:  16 bits     The source port number.
  * Destination Port:  16 bits     The destination port number.
  * Sequence Number:  32 bits
    * The sequence number of the first data octet in this segment \(except

          when SYN is present\). If SYN is present the sequence number is the

          initial sequence number \(ISN\) and the first data octet is ISN+1.
  * Acknowledgment Number:  32 bits
    * If the ACK control bit is set this field contains the value of the

          next sequence number the sender of the segment is expecting to

          receive.  Once a connection is established this is always sent.
  * Data Offset:  4 bits
    * The number of 32 bit words in the TCP Header.  This indicates where

          the data begins.  The TCP header \(even one including options\) is an

          integral number of 32 bits long.
  * Reserved:  6 bits     Reserved for future use.  Must be zero.
  * Control Bits:  6 bits \(from left to right\):
    * URG:  Urgent Pointer field significant
    * ACK:  Acknowledgment field significant
    * PSH:  Push Function
    * RST:  Reset the connection
    * SYN:  Synchronize sequence numbers
    * FIN:  No more data from sender
  * Window:  16 bits
    * The number of data octets beginning with the one indicated in the

          acknowledgment field which the sender of this segment is willing to

          accept.
  * Checksum:  16 bits
    * The checksum field is the 16 bit one's complement of the one's

          complement sum of all 16 bit words in the header and text.  If a

          segment contains an odd number of header and text octets to be

          checksummed, the last octet is padded on the right with zeros to

          form a 16 bit word for checksum purposes.  The pad is not

          transmitted as part of the segment.  While computing the checksum,

          the checksum field itself is replaced with zeros.
  * The checksum also covers a 96 bit pseudo header conceptually     prefixed to the TCP header.  This pseudo header contains the Source     Address, the Destination Address, the Protocol, and TCP length.
    * This gives the TCP protection against misrouted segments.  This

          information is carried in the Internet Protocol and is transferred

          across the TCP/Network interface in the arguments or results of

          calls by the TCP on the IP.

    * The TCP Length is the TCP header length plus the data length in

            octets \(this is not an explicitly transmitted quantity, but is

            computed\), and it does not count the 12 octets of the pseudo

            header.
  * Urgent Pointer:  16 bits
    * This field communicates the current value of the urgent pointer as a

          positive offset from the sequence number in this segment.  The

          urgent pointer points to the sequence number of the octet following

          the urgent data.  This field is only be interpreted in segments with

          the URG control bit set.
  * Options:  variable
    * Options may occupy space at the end of the TCP header and are a

          multiple of 8 bits in length.  All options are included in the

          checksum.  An option may begin on any octet boundary.  There are two

          cases for the format of an option:

      * Case 1:  A single octet of option-kind.
      * Case 2:  An octet of option-kind, an octet of option-length, and

                       the actual option-data octets.

    * The option-length counts the two octets of option-kind and

          option-length as well as the option-data octets.

    * Note that the list of options may be shorter than the data offset

          field might imply.  The content of the header beyond the

          End-of-Option option must be header padding \(i.e., zero\).

    *  A TCP must implement all options.
    * check details



* Check terminology
* LISTEN - represents waiting for a connection request from any remote   TCP and port.
  * SYN-SENT - represents waiting for a matching connection request

        after having sent a connection request.

  * SYN-RECEIVED - represents waiting for a confirming connection

        request acknowledgment after having both received and sent a

        connection request.

  * ESTABLISHED - represents an open connection, data received can be

        delivered to the user.  The normal state for the data transfer phase

        of the connection.

  * FIN-WAIT-1 - represents waiting for a connection termination request

        from the remote TCP, or an acknowledgment of the connection

        termination request previously sent.

  * FIN-WAIT-2 - represents waiting for a connection termination request

        from the remote TCP.

  * CLOSE-WAIT - represents waiting for a connection termination request

        from the local user.

  * CLOSING - represents waiting for a connection termination request

        acknowledgment from the remote TCP.

  * LAST-ACK - represents waiting for an acknowledgment of the

        connection termination request previously sent to the remote TCP

        \(which includes an acknowledgment of its connection termination

        request\).

  * TIME-WAIT - represents waiting for enough time to pass to be sure

        the remote TCP received the acknowledgment of its connection

        termination request.

  * CLOSED - represents no connection state at all.
* A TCP connection progresses from one state to another in response to

    events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,

    ABORT, and STATUS; the incoming segments, particularly those

    containing the SYN, ACK, RST and FIN flags; and timeouts.

* A fundamental notion in the design is that every octet of data sent

    over a TCP connection has a sequence number.  Since every octet is

    sequenced, each of them can be acknowledged.  The acknowledgment

    mechanism employed is cumulative so that an acknowledgment of sequence

    number X indicates that all octets up to but not including X have been

    received.  This mechanism allows for straight-forward duplicate

    detection in the presence of retransmission.  Numbering of octets

    within a segment is that the first data octet immediately following

    the header is the lowest numbered, and the following octets are

    numbered consecutively.

* A segment on the retransmission queue is fully acknowledged if the sum

    of its sequence number and length is less or equal than the

    acknowledgment value in the incoming segment.

*  Note that when the receive window is zero no segments should be

    acceptable except ACK segments.  Thus, it is be possible for a TCP to

    maintain a zero receive window while transmitting data and receiving

    ACKs.  However, even when the receive window is zero, a TCP must

    process the RST and URG fields of all incoming segments.

* Control information is not physically

    carried in the segment data space.  Consequently, we must adopt rules

    for implicitly assigning sequence numbers to control.  The SYN and FIN

    are the only controls requiring this protection, and these controls

    are used only at connection opening and closing.  For sequence number

    purposes, the SYN is considered to occur before the first actual data

    octet of the segment in which it occurs, while the FIN is considered

    to occur after the last actual data octet in a segment in which it

    occurs.  The segment length \(SEG.LEN\) includes both data and sequence

    space occupying controls.  When a SYN is present then SEG.SEQ is the

    sequence number of the SYN.

* The protocol places no restriction on a particular connection being

    used over and over again.  A connection is defined by a pair of

    sockets.  New instances of a connection will be referred to as

    incarnations of the connection.

  * the problem that arises from this is

      -- "how does the TCP identify duplicate segments from previous

      incarnations of the connection?"

  * To avoid confusion we must prevent segments from one incarnation of a

      connection from being used while the same sequence numbers may still

      be present in the network from an earlier incarnation.  We want to

      assure this, even if a TCP crashes and loses all knowledge of the

      sequence numbers it has been using.  When new connections are created,

      an initial sequence number \(ISN\) generator is employed which selects a

      new 32 bit ISN.  The generator is bound to a \(possibly fictitious\) 32

      bit clock whose low order bit is incremented roughly every 4

      microseconds.  Thus, the ISN cycles approximately every 4.55 hours.

      Since we assume that segments will stay in the network no more than

      the Maximum Segment Lifetime \(MSL\) and that the MSL is less than 4.55

      hours we can reasonably assume that ISN's will be unique.

* For each connection there is a send sequence number and a receive

    sequence number.  The initial send sequence number \(ISS\) is chosen by

    the data sending TCP, and the initial receive sequence number \(IRS\) is

    learned during the connection establishing procedure.

  * For a connection to be established or initialized, the two TCPs must

      synchronize on each other's initial sequence numbers.  This is done in

      an exchange of connection establishing segments carrying a control bit

      called "SYN" \(for synchronize\) and the initial sequence numbers.

  * The synchronization requires each side to send it's own initial

      sequence number and to receive a confirmation of it in acknowledgment

      from the other side.  Each side must also receive the other side's

      initial sequence number and send a confirming acknowledgment.

* To be sure that a TCP does not create a segment that carries a

    sequence number which may be duplicated by an old segment remaining in

    the network, the TCP must keep quiet for a maximum segment lifetime

    \(MSL\) before assigning any sequence numbers upon starting up or

    recovering from a crash in which memory of sequence numbers in use was

    lost.  For this specification the MSL is taken to be 2 minutes.  This

    is an engineering choice, and may be changed if experience indicates

    it is desirable to do so.  Note that if a TCP is reinitialized in some

    sense, yet retains its memory of sequence numbers in use, then it need

    not wait at all; it must only be sure to use sequence numbers larger

    than those recently used.

* large range of sequence numbers
* The "three-way handshake" is the procedure used to establish a

    connection.  This procedure normally is initiated by one TCP and

    responded to by another TCP.  The procedure also works if two TCP

    simultaneously initiate the procedure.  When simultaneous attempt

    occurs, each TCP receives a "SYN" segment which carries no

    acknowledgment after it has sent a "SYN".  Of course, the arrival of

    an old duplicate "SYN" segment can potentially make it appear, to the

    recipient, that a simultaneous connection initiation is in progress.

    Proper use of "reset" segments can disambiguate these cases.

  * Several examples of connection initiation follow.  Although these

      examples do not show connection synchronization using data-carrying

      segments, this is perfectly legitimate, so long as the receiving TCP

      doesn't deliver the data to the user until it is clear the data is

      valid \(i.e., the data must be buffered at the receiver until the

      connection reaches the ESTABLISHED state\).  The three-way handshake

      reduces the possibility of false connections.



```text
 1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

*  Note that the

    sequence number of the segment in line 5 is the same as in line 4

    because the ACK does not occupy sequence number space \(if it did, we

    would wind up ACKing ACK's!\).



* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* an rst contains the seq number it reference, not the one it should have by now
* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* There are three groups of states:
  * 1.  If the connection does not exist \(CLOSED\) then a reset is sent

        in response to any incoming segment except another reset.  In

        particular, SYNs addressed to a non-existent connection are rejected

        by this means.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the CLOSED state.

  * 2.  If the connection is in any non-synchronized state \(LISTEN,

        SYN-SENT, SYN-RECEIVED\), and the incoming segment acknowledges

        something not yet sent \(the segment carries an unacceptable ACK\), or

        if an incoming segment has a security level or compartment which

        does not exactly match the level and compartment requested for the

        connection, a reset is sent.

    * If our SYN has not been acknowledged and the precedence level of the

          incoming segment is higher than the precedence level requested then

          either raise the local precedence level \(if allowed by the user and

          the system\) or send a reset; or if the precedence level of the

          incoming segment is lower than the precedence level requested then

          continue as if the precedence matched exactly \(if the remote TCP

          cannot raise the precedence level to match ours this will be

          detected in the next segment it sends, and the connection will be

          terminated then\).  If our SYN has been acknowledged \(perhaps in this

          incoming segment\) the precedence level of the incoming segment must

          match the local precedence level exactly, if it does not a reset

          must be sent.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the same state.

  * If the connection is in a synchronized state \(ESTABLISHED,

        FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\),

        any unacceptable segment \(out of window sequence number or

        unacceptible acknowledgment number\) must elicit only an empty

        acknowledgment segment containing the current send-sequence number

        and an acknowledgment indicating the next sequence number expected

        to be received, and the connection remains in the same state.

    * If an incoming segment has a security level, or compartment, or

          precedence which does not exactly match the level, and compartment,

          and precedence requested for the connection,a reset is sent and

          connection goes to the CLOSED state.  The reset takes its sequence

          number from the ACK field of the incoming segment.
*  In all states except SYN-SENT, all reset \(RST\) segments are validated

    by checking their SEQ-fields.  A reset is valid if its sequence number

    is in the window.  In the SYN-SENT state \(a RST received in response

    to an initial SYN\), the RST is acceptable if the ACK field

    acknowledges the SYN.

  * The receiver of a RST first validates it, then changes state.  If the

      receiver was in the LISTEN state, it ignores it.  If the receiver was

      in SYN-RECEIVED state and had previously been in the LISTEN state,

      then the receiver returns to the LISTEN state, otherwise the receiver

      aborts the connection and goes to the CLOSED state.  If the receiver

      was in any other state, it aborts the connection and advises the user

      and goes to the CLOSED state.



* CLOSE is an operation meaning "I have no more data to send."
* The user who CLOSEs may continue to RECEIVE

    until he is told that the other side has CLOSED also

* A TCP will reliably deliver all

    buffers SENT before the connection was CLOSED

* There are essentially three cases:
  * The user initiates by telling the TCP to CLOSE the connection
    * In this case, a FIN segment can be constructed and placed on the

          outgoing segment queue.  No further SENDs from the user will be

          accepted by the TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs

          are allowed in this state.  All segments preceding and including FIN

          will be retransmitted until acknowledged.  When the other TCP has

          both acknowledged the FIN and sent a FIN of its own, the first TCP

          can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not

          send its own FIN until its user has CLOSED the connection also.
  * 2\) The remote TCP initiates by sending a FIN control signal
    * If an unsolicited FIN arrives from the network, the receiving TCP

          can ACK it and tell the user that the connection is closing.  The

          user will respond with a CLOSE, upon which the TCP can send a FIN to

          the other TCP after sending any remaining data.  The TCP then waits

          until its own FIN is acknowledged whereupon it deletes the

          connection.  If an ACK is not forthcoming, after the user timeout

          the connection is aborted and the user is told.
  * Both users CLOSE simultaneously
    * A simultaneous CLOSE by users at both ends of a connection causes

          FIN segments to be exchanged.  When all segments preceding the FINs

          have been processed and acknowledged, each TCP can ACK the FIN it

          has received.  Both will, upon receiving these ACKs, delete the

          connection.



* Read 3.7 Data Communication
* 
## PLT & GOT

* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

