# Hacking : The Art of Exploitation Notes

*  Test if `set disassembly intel` works
  * Write it in the `~./.gdbinit` file
  * Test if you can define the hook-stop there too
* If the c source code was compiled with `gcc` with the  `-d` options, `gdb` can have access to the source code with `list`
  * i guess it's only the case when having acces to the source code, but you can examine a variable with `x/xw var`
    * And retrieve the address of a variable with `&var`
* Verify that the shorthand of the `info` commands actually work
*  `bt` Shows the stack backtrace



* 2 complements \(binary\) :  "First, the binary value 01001001 is shown to be positive 73. Then all the bits are flipped, and 1 is added to result in the two’s complement representation for negative 73, 10110111. When these two values are added together, the result of the original 8 bits is 0"



* "\*" Will show the value at the address pointing by a pointer
* Field with paramaters : `%<nb>` : minimum width of nb, will be padded with space
  * `%0<nb>` Minimum with of nb, will be padded with 0
* As discussed earlier, dividing the integer 13 by 5 will round down to the incorrect answer of 2, even if this value is being stored into a floating-point variable. However, if these integer variables are typecast into floats, they will be treated as such. This allows for the correct calculation of 2.6.
* This code uses the format parameter %p to output memory addresses. This is shorthand meant for displaying pointers and is basically equivalent to 0x%08x.
* First, pointers cannot be dereferenced unless they have a type. In order to retrieve the value stored in the pointer’s memory address, the compiler must first know what type of data it is. Secondly, void pointers must also be typecast before doing pointer arithmetic. These are fairly intuitive limitations, which means that a void pointer’s main purpose is to simply hold a memory address.
* for\(i=0; i &lt; 5; i++\) { // Iterate through the int array with the int\_pointer. printf\("\[char pointer\] points to %p, which contains the char '%c'\n", void\_pointer, _\(\(char_ \) void\_pointer\)\); void\_pointer = \(void _\) \(\(char_ \) void\_pointer + 1\); }
* With the data types defined by typecasting, anything that is big enough to hold a four-byte value can work the same way as a void pointer. In pointer\_types5.c, an unsigned integer is used to store this address.
  * for\(i=0; i &lt; 5; i++\) { // Iterate through the int array with the int\_pointer. printf\("\[hacky\_nonpointer\] points to %p, which contains the char '%c'\n", hacky\_nonpointer, _\(\(char_ \) hacky\_nonpointer\)\); hacky\_nonpointer = hacky\_nonpointer + sizeof\(char\); }
* The important thing to remember about variables in C is that the compiler is the only thing that cares about a variable’s type.
* int main\(int arg\_count, char \*arg\_list\[\]\)
  * 0th argument = executble name
* The zeroth argument is always the name of the executing binary, and the rest of the argument array \(often called an argument vector\) contains the remaining arguments as strings.
* do a global chapter on programming concepts, add variables scope



* The backtrace also shows the nested function calls by looking at records kept on the stack. Each time a function is called, a record called a stack frame is put on the stack. Each line in the backtrace corresponds to a stack frame. Each stack frame also contains the local variables for that context. The local variables contained in each stack frame can be shown in GDB by adding the word full to the backtrace command.
* In addition to globals, variables can also be defined as static variables by prepending the keyword static to the variable definition. Similar to global variables, a static variable remains intact between function calls; however, static variables are also akin to local variables since they remain local within a particular function context. One different and unique feature of static variables is that they are only initialized once. The code in static.c will help explain these concepts.
  * Notice that the static\_var retains its value between subsequent calls to function\(\). This is because static variables retain their values, but also because they are only initialized once.



* 


* C `open()` options flags :
  * The access mode must use at least one of the following three flags:
    * O\_RDONLY Open file for read-only access. O\_WRONLY Open file for write-only access. O\_RDWR Open file for both read and write access.
  * These flags can be combined with several other optional flags using the bitwise OR operator. A few of the more common and useful of these flags are as follows:
    * O\_APPEND Write data at the end of the file. O\_TRUNC If the file already exists, truncate the file to 0 length. O\_CREAT Create the file if it doesn’t exist.
* If the O\_CREAT flag is used in access mode for the open\(\) function, an additional argument is needed to define the file permissions of the newly created file. This argument uses bit flags defined in sys/stat.h, which can be combined with each other using bitwise OR logic. S\_IRUSR Give the file read permission for the user \(owner\). S\_IWUSR Give the file write permission for the user \(owner\). S\_IXUSR Give the file execute permission for the user \(owner\). S\_IRGRP Give the file read permission for the group. S\_IWGRP Give the file write permission for the group. S\_IXGRP Give the file execute permission for the group. S\_IROTH Give the file read permission for other \(anyone\). S\_IWOTH Give the file write permission for other \(anyone\). S\_IXOTH Give the file execute permission for other \(anyone\).
* Each permission corresponds to a bit flag; read is 4 \(100 in binary\), write is 2 \(010 in binary\), and execute is 1 \(001 in binary\). Since each value only contains unique bits, a bitwise OR operation achieves the same result as adding these numbers together does. These values can be added together to define permissions for user, group, and other using the chmod command.
* In C, when the filename for a \#include is surrounded by &lt; and &gt;, the compiler looks for this file in standard include paths, such as /usr/include/. If the filename is surrounded by quotes, the compiler looks in the current directory. Therefore, if hacking.h is in the same directory as a program, it can be included with that program by typing \#include "hacking.h".
* Sometimes there are multiple variables that should be grouped together and treated like one. In C, structs are variables that can contain many other variables.

```text
struct tm {
int tm_sec; /* seconds */
int tm_min; /* minutes */
int tm_hour; /* hours */
int tm_mday; /* day of the month */
int tm_mon; /* month */
int tm_year; /* year */
int tm_wday; /* day of the week */
int tm_yday; /* day in the year */
int tm_isdst; /* daylight saving time */
};

struct tm current_time, *time_ptr;
time_ptr = &current_time; // Set time_ptr to the address of
// the current_time struct.
hour = current_time.tm_hour; // Direct access
minute = time_ptr->tm_min; // Access via pointer
second = *((int *) time_ptr); // Hacky pointer access
```

* The time\(\) function will return the number of seconds since January 1, 1970. Time on Unix systems is kept relative to this rather arbitrary point in time, which is also known as the epoch.
* int \(\*function\_ptr\) \(\);
* Since computers are deterministic machines, it is impossible for them to produce truly random numbers. But many applications require some form of randomness. The pseudo-random number generator functions fill this need by generating a stream of numbers that is pseudo-random. These functions can produce a seemingly random sequence of numbers started from a seed number; however, the same exact sequence can be generated again with the same seed. Deterministic machines cannot produce true randomness, but if the seed value of the pseudo-random generation function isn’t known, the sequence will seem random. The generator must be seeded with a value using the function srand\(\), and from that point on, the function rand\(\) will return a pseudo-random number from 0 to RAND\_MAX. These functions and RAND\_MAX are defined in stdlib.h. While the numbers rand\(\) returns will appear to be random, they are dependent on the seed value provided to srand\(\). To maintain pseudo-randomness between subsequent program executions, the randomizer must be seeded with a different value each time. One common practice is to use the number of seconds since epoch \(returned from the time\(\) function\) as the seed.



