# Hacking : The Art of Exploitation Notes

## Shellcode

* The Unix manual pages \(accessed with the man command\) are separated into sections. Section 2 contains the manual pages for system calls
* Every possible Linux system call is enumerated, so they can be referenced by numbers when making the calls in assembly. These syscalls are listed in /usr/include/asm-i386/unistd.h.
* The int instruction sends an interrupt signal to the kernel, defined by its single operand. With the Linux kernel, interrupt 0x80 is used to tell the kernel to make a system call. When the int 0x80 instruction is executed, the kernel will make a system call based on the first four registers. The EAX register is used to specify which system call to make, while the EBX, ECX, and EDX registers are used to hold the first, second, and third arguments to the system call.
* ```text
  helloworld.asm
  section .data ; Data segment
  msg db "Hello, world!", 0x0a ; The string and newline char
  section .text ; Text segment
  global _start ; Default entry point for ELF linking
  _start:
  286 0x500
   ; SYSCALL: write(1, msg, 14)
   mov eax, 4 ; Put 4 into eax, since write is syscall #4.
   mov ebx, 1 ; Put 1 into ebx, since stdout is 1.
   mov ecx, msg ; Put the address of the string into ecx.
   mov edx, 14 ; Put 14 into edx, since our string is 14 bytes.
   int 0x80 ; Call the kernel to make the system call happen.
   ; SYSCALL: exit(0)
   mov eax, 1 ; Put 1 into eax, since exit is syscall #1.
   mov ebx, 0 ; Exit with success.
   int 0x80 ; Do the syscall.
 
  ```

  * We are going to create an executable and linking format \(ELF\) binary, so the global \_start line shows the linker where the assembly instructions begin
  * The nasm assembler with the -f elf argument will assemble the helloworld.asm into an object file ready to be linked as an ELF binary.
  * By default, this object file will be called helloworld.o. The linker program ld will produce an executable a.out binary from the assembled object.
* Shellcode is literally injected into a running program, where it takes over like a biological virus inside a cell. Since shellcode isn’t really an executable program, we don’t have the luxury of declaring the layout of data in memory or even using other memory segments. Our instructions must be self-contained and ready to take over control of the processor regardless of its current state. This is commonly referred to as position-independent code.
  * The string’s absolute memory address needs to be calculated relative to EIP. Since EIP cannot be accessed from assembly instructions, however, we need to use some sort of trick.
* The stack is so integral to the x86 architecture that there are special instructions for its operations.
  * push  &lt;source&gt; Push the source operand to the stack. 
  * pop &lt;destination&gt; Pop a value from the stack and store in the destination operand.
  * call &lt;location&gt; Call a function, jumping the execution to the address in the location operand. This location can be relative or absolute. The address of the instruction following the call is pushed to the stack, so that execution can return later.
  * ret Return from a function, popping the return address from the stack and jumping execution there.
* . If the string is placed directly after a call instruction, the address of the string will get pushed to the stack as the return address. Instead of calling a function, we can jump past the string to a pop instruction that will take the address off the stack and into a register. The following assembly instructions demonstrate this technique.
  * ```text
    helloworld1.s
    BITS 32 ; Tell nasm this is 32-bit code.
     call mark_below ; Call below the string to instructions
     db "Hello, world!", 0x0a, 0x0d ; with newline and carriage return bytes.
    mark_below:
    ; ssize_t write(int fd, const void *buf, size_t count);
     pop ecx ; Pop the return address (string ptr) into ecx.
     mov eax, 4 ; Write syscall #.
     mov ebx, 1 ; STDOUT file descriptor
    Instruction Description
    push <source> Push the source operand to the stack.
    pop <destination> Pop a value from the stack and store in the destination operand.
    call <location> Call a function, jumping the execution to the address in the location
    operand. This location can be relative or absolute. The address of the
    instruction following the call is pushed to the stack, so that execution can
    return later.
    ret Return from a function, popping the return address from the stack and
    jumping execution there.
    288 0x500
     mov edx, 15 ; Length of the string
     int 0x80 ; Do syscall: write(1, string, 14)
    ; void _exit(int status);
     mov eax, 1 ; Exit syscall #
     mov ebx, 0 ; Status = 0
     int 0x80 ; Do syscall: exit(0)
    ```
* The nasm assembler converts assembly language into machine code and a corresponding tool called ndisasm converts machine code into assembly
* Another way to debug programs is with core dumps. From a root prompt, the OS can be told to dump memory when the program crashes by using the command ulimit -c unlimited. This means that dumped core files are allowed to get as big as needed. Now, when the program crashes, the memory will be dumped to disk as a core file, which can be examined using GDB.
* Normally, strings are terminated by a null byte, but here, the shell was kind enough to remove these null bytes for us. This, however, totally destroys the meaning of the machine code. Often, shellcode will be injected into a process as a string, using functions like strcpy\(\). Such functions will simply terminate at the first null byte, producing incomplete and unusable shellcode in memory. In order for the shellcode to survive transit, it must be redesigned so it doesn’t contain any null bytes.
* The call instruction allows for much longer jump distances, Shellcode 291 which means that a small value like 19 will have to be padded with leading zeros resulting in null bytes. One way around this problem takes advantage of two’s complement. A small negative number will have its leading bits turned on, resulting in 0xff bytes. This means that, if we call using a negative value to move backward in execution, the machine code for that instruction won’t have any null bytes. The following revision of the helloworld shellcode uses a standard implementation of this trick: Jump to the end of the shellcode to a call instruction which, in turn, will jump back to a pop instruction at the beginning of the shellcode.
* Notice that the first jmp instruction is actually jmp short. This means execution can only jump a maximum of approximately 128 bytes in either direction. The normal jmp instruction, as well as the call instruction \(which has no short version\), allows for much longer jumps.
  * The EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP registers are 32 bits in width. The E stands for extended, because these were originally 16-bit registers called AX, BX, CX, DX, SI, DI, BP, and SP. These original 16-bit versions of the registers can still be used for accessing the first 16 bits of each corresponding 32-bit register. Furthermore, the individual bytes of the AX, BX, CX, and DX registers can be accessed as 8-bit registers called AL, AH, BL, BH, CL, CH, DL, and DH, where L stands for low byte and H for high byte
* inc &lt;target&gt; Increment the target operand by adding 1 to it.
  * dec &lt;target&gt;  Decrement the target operand by subtracting 1 from it.
  * Check the added instructions at add  &lt;dest&gt;, &lt;source&gt;
* The xor instruction performs an exclusive or operation on the bits in a register. Since 1 xored with 1 results in a 0, and 0 xored with 0 results in a 0, any value xored with itself will result in 0. This is the same result as with any value subtracted from itself, but the xor instruction doesn’t modify processor flags, so it’s considered to be a cleaner method
* To spawn a shell, we just need to make a system call to execute the /bin/sh shell program. System call number 11, execve\(\), is similar to the C execute\(\) function
* The lea instruction, whose name stands for load effective address, works like the address-of operator in C.
  * lea &lt;dest&gt;,&lt;source&gt;,  Load the effective address of the source operand into the destination operand.
* With Intel assembly syntax, operands can be dereferenced as pointers if they are surrounded by square brackets. For example, the following instruction in assembly will treat EBX+12 as a pointer and write eax to where it’s pointing. 
  * 89 43 0C mov \[ebx+12\],eax
* To help mitigate rampant privilege escalation, some privileged processes will lower their effective privileges while doing things that don’t require that kind of access. This can be done with the seteuid\(\) function, which will set the effective user ID. By changing the effective user ID, the privileges of the process can be changed.
* Fortunately, the privileges can easily be restored at the beginning of our shellcode with a system call to set the privileges back to root. The most complete way to do this is with a setresuid\(\) system call, which sets the real, effective, and saved user IDs
* There is a single-byte x86 instruction called cdq, which stands for convert doubleword to quadword. Instead of using operands, this instruction always gets its source from the EAX register and stores the results between the EDX and EAX registers. Since the registers are 32-bit doublewords, it takes two registers to store a 64-bit quadword. The conversion is simply a matter of extending the sign bit from a 32-bit integer to 64-bit integer. Operationally, this means if the sign bit of EAX is 0, the cdq instruction will zero the EDX register. Using xor to zero the EDX register requires two bytes; so, if EAX is already zeroed, using the cdq instruction to zero EDX will save one byte
* Since the stack is 32-bit aligned, a single byte value pushed to the stack will be aligned as a doubleword. When this value is popped off, it will be sign-extended, filling the entire register. The instructions that push a single byte and pop it back into a register take three bytes, while using xor to zero the register and moving a single byte takes four bytes
  * 31 C0 xor eax,eax B0 0B mov al,0xb
  * compared to 6A 0B push byte +0xb 58 pop eax
  * Valid sizes are BYTE for one byte, WORD for two bytes, and DWORD for four bytes. These sizes can be implied from register widths, so moving into the AL register implies the BYTE size.
* These familiar socket functions can all be accessed with a single Linux system call, aptly named socketcall\(\). This is syscall number 102, which has a slightly cryptic manual page
  * The possible call numbers for the first argument are listed in the linux/net.h include file
  * So, to make socket system calls using Linux, EAX is always 102 for socketcall\(\), EBX contains the type of socket call, and ECX is a pointer to the socket call’s arguments. The calls are simple enough, but some of them require a sockaddr structure, which must be built by the shellcode
* Standard input, standard output, and standard error are the three standard file descriptors used by programs to perform standard I/O. Sockets, too, are just file descriptors that can be read from and written to. By simply swapping the standard input, output, and error of the spawned shell with the connected socket file descriptor, the shell will write output and errors to the socket and read its input from the bytes that the socket received. There is a system call specifically for duplicating file descriptors, called dup2. This is system call number 63.
* condiotionnal jump instruction
* The status flags set by the cmp instruction are also set by most other instructions, describing the attributes of the instruction’s result. These flags are carry flag \(CF\), parity flag \(PF\), adjust flag \(AF\), overflow flag \(OF\), zero flag \(ZF\), and sign flag \(SF\). The last two flags are the most useful and the easiest to understand. The zero flag is set to true if the result is zero, otherwise it is false. The sign flag is simply the most significant bit of the result, which is true if the result is negative and false otherwise.
* h the xchg \(exchange\) instruction. This instruction swaps the values between the source and destination operands:
  * xchg &lt;dest&gt;,&lt;source&gt;,  Exchange the values between the two operands
* Port-binding shellcode is easily foiled by firewalls. Most firewalls will block incoming connections, except for certain ports with known services. This limits the user’s exposure and will prevent port-binding shellcode from receiving a connection. Software firewalls are now so common that port-bind shellcode has little chance of actually working in the wild.
  * However, firewalls typically do not filter outbound connections, since that would hinder usability. From inside the firewall, a user should be able to access any web page or make any other outbound connections. This means that if the shellcode initiates the outbound connection, most firewalls will allow it.
  * Instead of waiting for a connection from an attacker, connect-back shellcode initiates a TCP connection back to the attacker’s IP address.

## Counter measure

* t. A remote target will be a server program that accepts incoming connections. In Unix, these programs are usually system daemons. A daemon is a program that runs in the background and detaches from the controlling terminal in a certain way. The term daemon was first coined by MIT hackers in the 1960s. It refers to a molecule-sorting demon from an 1867 thought experiment by a physicist named James Maxwell. In the thought experiment, Maxwell’s demon is a being with the supernatural ability to effortlessly perform difficult tasks, apparently violating the second law of thermodynamics. Similarly, in Linux, system daemons tirelessly perform tasks such as providing SSH service and keeping system logs. Daemon programs typically end with a d to signify they are daemons, such as sshd or syslogd.
* Signals provide a method of interprocess communication in Unix. When a process receives a signal, its flow of execution is interrupted by the operating system to call a signal handler. Signals are identified by a number, and each one has a default signal handler. For example, when CTRL-C is typed in a program’s controlling terminal, an interrupt signal is sent, which has a default signal handler that exits the program. This allows the program to be interrupted, even if it is stuck in an infinite loop.
* Custom signal handlers can be registered using the signal\(\) function.
* Specific signals can be sent to a process using the kill command. By default, the kill command sends the terminate signal \(SIGTERM\) to a process. With the -l command-line switch, kill lists all the possible signals
  * Finally, the SIGKILL signal is sent using kill -9. This signal’s handler cannot be changed, so kill -9 can always be used to kill processes
* Forking process \(deamon call\)
  * When the program is run, it just exits. In order to debug this program, GDB needs to be told to follow the child process, as opposed to following the parent. This is done by setting follow-fork-mode to child. After this change, the debugger will follow execution into the child process, where the breakpoint can be hit.
* netcat is run in listen mode with an ampersand \(&\) appended to the end, which sends the process to the background.
* In our case, there’s really no need to open a new connection, since we already have an open socket from the web request. Since we’re mucking around inside the tinyweb daemon, with a little debugging we can reuse the existing socket for the root shell. This prevents additional TCP connections from being logged and allows exploitation in cases where the target host cannot open outbound connections
* select-frame 1 in bt
* . Our /bin/sh string is already slightly obfuscated since it’s pushed to the stack in four-byte chunks, but a network IDS could also look for packets that contain the strings /bin and //sh. These types of network
  * To hide the string, we will simply add 5 to each byte in the string. Then, after the string has been pushed to the stack, the shellcode will subtract 5 from each string byte on the stack
* The NOP sled is another signature easy to detect by network IDSes and IPSes. Large blocks of 0x90 aren’t that common, so if a network security mechanism sees something like this, it’s probably an exploit. To avoid this signature, we can use different single-byte instructions instead of NOP. There are several one-byte instructions—the increment and decrement instructions for various registers—that are also printable ASCII characters.
  * copy the table of Instruction Hex ASCII



* Polymorphic shellcode refers to any shellcode that changes itself. The encoding shellcode from the previous section is technically polymorphic, since it modifies the string it uses while it’s running. The new NOP sled uses instructions that assemble into printable ASCII bytes. There are other instructions that fall into this printable range \(from 0x33 to 0x7e\); however, the total set is actually rather small.
  * the printable shellcode will use simple methods to build more complex shellcode on the stack. In this way, the printable shellcode will actually be instructions to make the real shellcode.
  * The first step is figuring out a way to zero out registers. Unfortunately, the XOR instruction on the various registers doesn’t assemble into the printable ASCII character range. One option is to use the AND bitwise operation, which assembles into the percent character \(%\) when using the EAX register. The assembly instruction of and eax, 0x41414141 will assemble to the printable machine code of %AAAA, since 0x41 in hexadecimal is the printable character A
    * Since the only case where the result is 1 is when both bits are 1, if two inverse values are ANDed onto EAX, EAX will become zero.
    * Thus, by using two printable 32-bit values that are bitwise inverses of each other, the EAX register can be zeroed without using any null bytes, and the resulting assembled machine code will be printable text.
* Amazingly, these instructions, combined with the AND eax instruction, are sufficient to build loader code that will inject the shellcode onto the stack and then execute it. The general technique is, first, to set ESP back behind the executing loader code \(in higher memory addresses\), and then to build the shellcode from end to start by pushing values onto the stack,

## RFC notes

* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* an rst contains the seq number it reference, not the one it should have by now
* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* There are three groups of states:
  * 1.  If the connection does not exist \(CLOSED\) then a reset is sent

        in response to any incoming segment except another reset.  In

        particular, SYNs addressed to a non-existent connection are rejected

        by this means.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the CLOSED state.

  * 2.  If the connection is in any non-synchronized state \(LISTEN,

        SYN-SENT, SYN-RECEIVED\), and the incoming segment acknowledges

        something not yet sent \(the segment carries an unacceptable ACK\), or

        if an incoming segment has a security level or compartment which

        does not exactly match the level and compartment requested for the

        connection, a reset is sent.

    * If our SYN has not been acknowledged and the precedence level of the

          incoming segment is higher than the precedence level requested then

          either raise the local precedence level \(if allowed by the user and

          the system\) or send a reset; or if the precedence level of the

          incoming segment is lower than the precedence level requested then

          continue as if the precedence matched exactly \(if the remote TCP

          cannot raise the precedence level to match ours this will be

          detected in the next segment it sends, and the connection will be

          terminated then\).  If our SYN has been acknowledged \(perhaps in this

          incoming segment\) the precedence level of the incoming segment must

          match the local precedence level exactly, if it does not a reset

          must be sent.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the same state.

  * If the connection is in a synchronized state \(ESTABLISHED,

        FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\),

        any unacceptable segment \(out of window sequence number or

        unacceptible acknowledgment number\) must elicit only an empty

        acknowledgment segment containing the current send-sequence number

        and an acknowledgment indicating the next sequence number expected

        to be received, and the connection remains in the same state.

    * If an incoming segment has a security level, or compartment, or

          precedence which does not exactly match the level, and compartment,

          and precedence requested for the connection,a reset is sent and

          connection goes to the CLOSED state.  The reset takes its sequence

          number from the ACK field of the incoming segment.
*  In all states except SYN-SENT, all reset \(RST\) segments are validated

    by checking their SEQ-fields.  A reset is valid if its sequence number

    is in the window.  In the SYN-SENT state \(a RST received in response

    to an initial SYN\), the RST is acceptable if the ACK field

    acknowledges the SYN.

  * The receiver of a RST first validates it, then changes state.  If the

      receiver was in the LISTEN state, it ignores it.  If the receiver was

      in SYN-RECEIVED state and had previously been in the LISTEN state,

      then the receiver returns to the LISTEN state, otherwise the receiver

      aborts the connection and goes to the CLOSED state.  If the receiver

      was in any other state, it aborts the connection and advises the user

      and goes to the CLOSED state.



* CLOSE is an operation meaning "I have no more data to send."
* The user who CLOSEs may continue to RECEIVE

    until he is told that the other side has CLOSED also

* A TCP will reliably deliver all

    buffers SENT before the connection was CLOSED

* There are essentially three cases:
  * The user initiates by telling the TCP to CLOSE the connection
    * In this case, a FIN segment can be constructed and placed on the

          outgoing segment queue.  No further SENDs from the user will be

          accepted by the TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs

          are allowed in this state.  All segments preceding and including FIN

          will be retransmitted until acknowledged.  When the other TCP has

          both acknowledged the FIN and sent a FIN of its own, the first TCP

          can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not

          send its own FIN until its user has CLOSED the connection also.
  * 2\) The remote TCP initiates by sending a FIN control signal
    * If an unsolicited FIN arrives from the network, the receiving TCP

          can ACK it and tell the user that the connection is closing.  The

          user will respond with a CLOSE, upon which the TCP can send a FIN to

          the other TCP after sending any remaining data.  The TCP then waits

          until its own FIN is acknowledged whereupon it deletes the

          connection.  If an ACK is not forthcoming, after the user timeout

          the connection is aborted and the user is told.
  * Both users CLOSE simultaneously
    * A simultaneous CLOSE by users at both ends of a connection causes

          FIN segments to be exchanged.  When all segments preceding the FINs

          have been processed and acknowledged, each TCP can ACK the FIN it

          has received.  Both will, upon receiving these ACKs, delete the

          connection.



* Read 3.7 Data Communication
* 
## PLT & GOT

* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

