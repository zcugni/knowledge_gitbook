# Hacking : The Art of Exploitation Notes

## RFC notes

* A TCP connection progresses from one state to another in response to

    events.  The events are the user calls, OPEN, SEND, RECEIVE, CLOSE,

    ABORT, and STATUS; the incoming segments, particularly those

    containing the SYN, ACK, RST and FIN flags; and timeouts.

* A fundamental notion in the design is that every octet of data sent

    over a TCP connection has a sequence number.  Since every octet is

    sequenced, each of them can be acknowledged.  The acknowledgment

    mechanism employed is cumulative so that an acknowledgment of sequence

    number X indicates that all octets up to but not including X have been

    received.  This mechanism allows for straight-forward duplicate

    detection in the presence of retransmission.  Numbering of octets

    within a segment is that the first data octet immediately following

    the header is the lowest numbered, and the following octets are

    numbered consecutively.

* A segment on the retransmission queue is fully acknowledged if the sum

    of its sequence number and length is less or equal than the

    acknowledgment value in the incoming segment.

*  Note that when the receive window is zero no segments should be

    acceptable except ACK segments.  Thus, it is be possible for a TCP to

    maintain a zero receive window while transmitting data and receiving

    ACKs.  However, even when the receive window is zero, a TCP must

    process the RST and URG fields of all incoming segments.

* Control information is not physically

    carried in the segment data space.  Consequently, we must adopt rules

    for implicitly assigning sequence numbers to control.  The SYN and FIN

    are the only controls requiring this protection, and these controls

    are used only at connection opening and closing.  For sequence number

    purposes, the SYN is considered to occur before the first actual data

    octet of the segment in which it occurs, while the FIN is considered

    to occur after the last actual data octet in a segment in which it

    occurs.  The segment length \(SEG.LEN\) includes both data and sequence

    space occupying controls.  When a SYN is present then SEG.SEQ is the

    sequence number of the SYN.

* The protocol places no restriction on a particular connection being

    used over and over again.  A connection is defined by a pair of

    sockets.  New instances of a connection will be referred to as

    incarnations of the connection.

  * the problem that arises from this is

      -- "how does the TCP identify duplicate segments from previous

      incarnations of the connection?"

  * To avoid confusion we must prevent segments from one incarnation of a

      connection from being used while the same sequence numbers may still

      be present in the network from an earlier incarnation.  We want to

      assure this, even if a TCP crashes and loses all knowledge of the

      sequence numbers it has been using.  When new connections are created,

      an initial sequence number \(ISN\) generator is employed which selects a

      new 32 bit ISN.  The generator is bound to a \(possibly fictitious\) 32

      bit clock whose low order bit is incremented roughly every 4

      microseconds.  Thus, the ISN cycles approximately every 4.55 hours.

      Since we assume that segments will stay in the network no more than

      the Maximum Segment Lifetime \(MSL\) and that the MSL is less than 4.55

      hours we can reasonably assume that ISN's will be unique.

* For each connection there is a send sequence number and a receive

    sequence number.  The initial send sequence number \(ISS\) is chosen by

    the data sending TCP, and the initial receive sequence number \(IRS\) is

    learned during the connection establishing procedure.

  * For a connection to be established or initialized, the two TCPs must

      synchronize on each other's initial sequence numbers.  This is done in

      an exchange of connection establishing segments carrying a control bit

      called "SYN" \(for synchronize\) and the initial sequence numbers.

  * The synchronization requires each side to send it's own initial

      sequence number and to receive a confirmation of it in acknowledgment

      from the other side.  Each side must also receive the other side's

      initial sequence number and send a confirming acknowledgment.

* To be sure that a TCP does not create a segment that carries a

    sequence number which may be duplicated by an old segment remaining in

    the network, the TCP must keep quiet for a maximum segment lifetime

    \(MSL\) before assigning any sequence numbers upon starting up or

    recovering from a crash in which memory of sequence numbers in use was

    lost.  For this specification the MSL is taken to be 2 minutes.  This

    is an engineering choice, and may be changed if experience indicates

    it is desirable to do so.  Note that if a TCP is reinitialized in some

    sense, yet retains its memory of sequence numbers in use, then it need

    not wait at all; it must only be sure to use sequence numbers larger

    than those recently used.

* large range of sequence numbers
* The "three-way handshake" is the procedure used to establish a

    connection.  This procedure normally is initiated by one TCP and

    responded to by another TCP.  The procedure also works if two TCP

    simultaneously initiate the procedure.  When simultaneous attempt

    occurs, each TCP receives a "SYN" segment which carries no

    acknowledgment after it has sent a "SYN".  Of course, the arrival of

    an old duplicate "SYN" segment can potentially make it appear, to the

    recipient, that a simultaneous connection initiation is in progress.

    Proper use of "reset" segments can disambiguate these cases.

  * Several examples of connection initiation follow.  Although these

      examples do not show connection synchronization using data-carrying

      segments, this is perfectly legitimate, so long as the receiving TCP

      doesn't deliver the data to the user until it is clear the data is

      valid \(i.e., the data must be buffered at the receiver until the

      connection reaches the ESTABLISHED state\).  The three-way handshake

      reduces the possibility of false connections.



```text
 1.  CLOSED                                               LISTEN

  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED

  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED

  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED

  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
```

*  Note that the

    sequence number of the segment in line 5 is the same as in line 4

    because the ACK does not occupy sequence number space \(if it did, we

    would wind up ACKing ACK's!\).



* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* an rst contains the seq number it reference, not the one it should have by now
* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* There are three groups of states:
  * 1.  If the connection does not exist \(CLOSED\) then a reset is sent

        in response to any incoming segment except another reset.  In

        particular, SYNs addressed to a non-existent connection are rejected

        by this means.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the CLOSED state.

  * 2.  If the connection is in any non-synchronized state \(LISTEN,

        SYN-SENT, SYN-RECEIVED\), and the incoming segment acknowledges

        something not yet sent \(the segment carries an unacceptable ACK\), or

        if an incoming segment has a security level or compartment which

        does not exactly match the level and compartment requested for the

        connection, a reset is sent.

    * If our SYN has not been acknowledged and the precedence level of the

          incoming segment is higher than the precedence level requested then

          either raise the local precedence level \(if allowed by the user and

          the system\) or send a reset; or if the precedence level of the

          incoming segment is lower than the precedence level requested then

          continue as if the precedence matched exactly \(if the remote TCP

          cannot raise the precedence level to match ours this will be

          detected in the next segment it sends, and the connection will be

          terminated then\).  If our SYN has been acknowledged \(perhaps in this

          incoming segment\) the precedence level of the incoming segment must

          match the local precedence level exactly, if it does not a reset

          must be sent.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the same state.

  * If the connection is in a synchronized state \(ESTABLISHED,

        FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\),

        any unacceptable segment \(out of window sequence number or

        unacceptible acknowledgment number\) must elicit only an empty

        acknowledgment segment containing the current send-sequence number

        and an acknowledgment indicating the next sequence number expected

        to be received, and the connection remains in the same state.

    * If an incoming segment has a security level, or compartment, or

          precedence which does not exactly match the level, and compartment,

          and precedence requested for the connection,a reset is sent and

          connection goes to the CLOSED state.  The reset takes its sequence

          number from the ACK field of the incoming segment.
*  In all states except SYN-SENT, all reset \(RST\) segments are validated

    by checking their SEQ-fields.  A reset is valid if its sequence number

    is in the window.  In the SYN-SENT state \(a RST received in response

    to an initial SYN\), the RST is acceptable if the ACK field

    acknowledges the SYN.

  * The receiver of a RST first validates it, then changes state.  If the

      receiver was in the LISTEN state, it ignores it.  If the receiver was

      in SYN-RECEIVED state and had previously been in the LISTEN state,

      then the receiver returns to the LISTEN state, otherwise the receiver

      aborts the connection and goes to the CLOSED state.  If the receiver

      was in any other state, it aborts the connection and advises the user

      and goes to the CLOSED state.



* CLOSE is an operation meaning "I have no more data to send."
* The user who CLOSEs may continue to RECEIVE

    until he is told that the other side has CLOSED also

* A TCP will reliably deliver all

    buffers SENT before the connection was CLOSED

* There are essentially three cases:
  * The user initiates by telling the TCP to CLOSE the connection
    * In this case, a FIN segment can be constructed and placed on the

          outgoing segment queue.  No further SENDs from the user will be

          accepted by the TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs

          are allowed in this state.  All segments preceding and including FIN

          will be retransmitted until acknowledged.  When the other TCP has

          both acknowledged the FIN and sent a FIN of its own, the first TCP

          can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not

          send its own FIN until its user has CLOSED the connection also.
  * 2\) The remote TCP initiates by sending a FIN control signal
    * If an unsolicited FIN arrives from the network, the receiving TCP

          can ACK it and tell the user that the connection is closing.  The

          user will respond with a CLOSE, upon which the TCP can send a FIN to

          the other TCP after sending any remaining data.  The TCP then waits

          until its own FIN is acknowledged whereupon it deletes the

          connection.  If an ACK is not forthcoming, after the user timeout

          the connection is aborted and the user is told.
  * Both users CLOSE simultaneously
    * A simultaneous CLOSE by users at both ends of a connection causes

          FIN segments to be exchanged.  When all segments preceding the FINs

          have been processed and acknowledged, each TCP can ACK the FIN it

          has received.  Both will, upon receiving these ACKs, delete the

          connection.



* Read 3.7 Data Communication
* 
## PLT & GOT

* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

