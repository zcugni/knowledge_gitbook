# Hacking : The Art of Exploitation Notes

## Counter measure

* Instead of preventing execution on the stack, this countermeasure randomizes the stack memory layout. When the memory layout is randomized, the attacker won’t be able to return execution into waiting shellcode, since he won’t know where it is.
* The randomization changes the location of everything on the stack, including environment variables.
* Since ASLR doesn’t stop the memory corruption, we can still use a bruteforcing BASH script to figure out the offset to the return address from the Countermeasures 381 beginning of the buffer. When a program exits, the value returned from the main function is the exit status. This status is stored in the BASH variable $?, which can be used to detect whether the program crashed.
  * Using BASH’s if statement logic, we can stop our brute-forcing script when it crashes the target.
  * Knowing the proper offset will let us overwrite the return address. However, we still cannot execute shellcode since its location is randomized.
* notice how similar the address in ESP is to the address of the buffer \(shown in bold\). This makes sense, since the stack pointer points to the stack and the buffer is on the stack. ESP’s value and the buffer’s address are changed by the same random value, because they are relative to each other.
  * Subtracting the value of ESP from the address of the buffer, we find that ESP is pointing 80 bytes \(or 20 words\) from the start of the buffer. Since the return address’s offset was 19 words, this means that after main’s final ret instruction, ESP points to stack memory found directly after the return address. This would be useful if there was a way to control EIP to go where ESP is pointing instead.
* Bouncing Off linux-gate
  * The technique described below doesn’t work with Linux kernels starting from 2.6.18
  * Bouncing off linux-gate refers to a shared object, exposed by the kernel, which looks like a shared library. The program ldd shows a program’s shared library dependencies.
  * Even in different programs and with ASLR enabled, linux-gate.so.1 is always present at the same address. This is a virtual dynamically shared object used by the kernel to speed up system calls, which means it’s needed in every process. It is loaded straight from the kernel and doesn’t exist anywhere on disk.
  * We are going to search this memory space for a certain assembly instruction, jmp esp. This instruction will jump EIP to where ESP is pointing
  * Using this information, a simple program can be written to find this pattern in the program’s own memory
  * When the program is compiled and run, it shows that this instruction exists at 0xffffe777
  * Putting it all together, if we overwrite the return address with the address 0xffffe777, then execution will jump into linux-gate when the main function returns. Since this is a jmp esp instruction, execution will immediately jump back out of linux-gate to wherever ESP happens to be pointing
* , you’ll notice the execve\(\) function replaces the currently running process with the new process image.
  * It seems like there could be a weakness here if the memory layout is randomized only when the process is started.
  * The first result looks very promising, but further attempts show that there is some degree of randomization happening when the new process is executed with execl\(\).
  * Using execl\(\) at least limits the randomness and gives us a ballpark address range. The remaining uncertainty can be handled with a NOP sled
  * 

## RFC notes

* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* an rst contains the seq number it reference, not the one it should have by now
* The principle reason for the three-way handshake is to prevent old

    duplicate connection initiations from causing confusion.  To deal with

    this, a special control message, reset, has been devised.  If the

    receiving TCP is in a  non-synchronized state \(i.e., SYN-SENT,

    SYN-RECEIVED\), it returns to LISTEN on receiving an acceptable reset.

    If the TCP is in one of the synchronized states \(ESTABLISHED,

    FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\), it

    aborts the connection and informs its user.  We discuss this latter

    case under "half-open" connections below.

* There are three groups of states:
  * 1.  If the connection does not exist \(CLOSED\) then a reset is sent

        in response to any incoming segment except another reset.  In

        particular, SYNs addressed to a non-existent connection are rejected

        by this means.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the CLOSED state.

  * 2.  If the connection is in any non-synchronized state \(LISTEN,

        SYN-SENT, SYN-RECEIVED\), and the incoming segment acknowledges

        something not yet sent \(the segment carries an unacceptable ACK\), or

        if an incoming segment has a security level or compartment which

        does not exactly match the level and compartment requested for the

        connection, a reset is sent.

    * If our SYN has not been acknowledged and the precedence level of the

          incoming segment is higher than the precedence level requested then

          either raise the local precedence level \(if allowed by the user and

          the system\) or send a reset; or if the precedence level of the

          incoming segment is lower than the precedence level requested then

          continue as if the precedence matched exactly \(if the remote TCP

          cannot raise the precedence level to match ours this will be

          detected in the next segment it sends, and the connection will be

          terminated then\).  If our SYN has been acknowledged \(perhaps in this

          incoming segment\) the precedence level of the incoming segment must

          match the local precedence level exactly, if it does not a reset

          must be sent.

    * If the incoming segment has an ACK field, the reset takes its

          sequence number from the ACK field of the segment, otherwise the

          reset has sequence number zero and the ACK field is set to the sum

          of the sequence number and segment length of the incoming segment.

          The connection remains in the same state.

  * If the connection is in a synchronized state \(ESTABLISHED,

        FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT\),

        any unacceptable segment \(out of window sequence number or

        unacceptible acknowledgment number\) must elicit only an empty

        acknowledgment segment containing the current send-sequence number

        and an acknowledgment indicating the next sequence number expected

        to be received, and the connection remains in the same state.

    * If an incoming segment has a security level, or compartment, or

          precedence which does not exactly match the level, and compartment,

          and precedence requested for the connection,a reset is sent and

          connection goes to the CLOSED state.  The reset takes its sequence

          number from the ACK field of the incoming segment.
*  In all states except SYN-SENT, all reset \(RST\) segments are validated

    by checking their SEQ-fields.  A reset is valid if its sequence number

    is in the window.  In the SYN-SENT state \(a RST received in response

    to an initial SYN\), the RST is acceptable if the ACK field

    acknowledges the SYN.

  * The receiver of a RST first validates it, then changes state.  If the

      receiver was in the LISTEN state, it ignores it.  If the receiver was

      in SYN-RECEIVED state and had previously been in the LISTEN state,

      then the receiver returns to the LISTEN state, otherwise the receiver

      aborts the connection and goes to the CLOSED state.  If the receiver

      was in any other state, it aborts the connection and advises the user

      and goes to the CLOSED state.



* CLOSE is an operation meaning "I have no more data to send."
* The user who CLOSEs may continue to RECEIVE

    until he is told that the other side has CLOSED also

* A TCP will reliably deliver all

    buffers SENT before the connection was CLOSED

* There are essentially three cases:
  * The user initiates by telling the TCP to CLOSE the connection
    * In this case, a FIN segment can be constructed and placed on the

          outgoing segment queue.  No further SENDs from the user will be

          accepted by the TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs

          are allowed in this state.  All segments preceding and including FIN

          will be retransmitted until acknowledged.  When the other TCP has

          both acknowledged the FIN and sent a FIN of its own, the first TCP

          can ACK this FIN.  Note that a TCP receiving a FIN will ACK but not

          send its own FIN until its user has CLOSED the connection also.
  * 2\) The remote TCP initiates by sending a FIN control signal
    * If an unsolicited FIN arrives from the network, the receiving TCP

          can ACK it and tell the user that the connection is closing.  The

          user will respond with a CLOSE, upon which the TCP can send a FIN to

          the other TCP after sending any remaining data.  The TCP then waits

          until its own FIN is acknowledged whereupon it deletes the

          connection.  If an ACK is not forthcoming, after the user timeout

          the connection is aborted and the user is told.
  * Both users CLOSE simultaneously
    * A simultaneous CLOSE by users at both ends of a connection causes

          FIN segments to be exchanged.  When all segments preceding the FINs

          have been processed and acknowledged, each TCP can ACK the FIN it

          has received.  Both will, upon receiving these ACKs, delete the

          connection.



* Read 3.7 Data Communication
* 
## PLT & GOT

* Since a program could use a function in a shared library many times, it’s useful to have a table to reference all the functions. Another special section in compiled programs is used for this purpose—the procedure linkage table \(PLT\). This section consists of many jump instructions, each one corresponding to the address of a function. It works like a springboard—each time a shared function needs to be called, control will pass through the PLT.
  * the procedure linking table is shown to be read only.
  * they aren’t jumping to addresses but to pointers to addresses
  * These addresses exist in another section, called the global offset table \(GOT\), which is writable. These addresses can be directly obtained by displaying the dynamic relocation entries for the binary by using objdump.
  * . Another advantage of overwriting the GOT is that the GOT entries are fixed per binary, so a different system with the same binary will have the same GOT entry at the same add

## GDB

* One elegant solution to this problem is to attach to the process after it’s already running. In the output below, GDB is used to attach to an alreadyrunning tinyweb process that was started in another terminal. The source is recompiled using the -g option to include debugging symbols that GDB can apply to the running process. 
  * reader@hacking:~/booksrc $ ps aux \| grep tinyweb root 13019 0.0 0.0 1504 344 pts/0 S+ 20:25 0:00 ./tinyweb reader 13104 0.0 0.0 2880 748 pts/2 R+ 20:27 0:00 grep tinyweb reader@hacking:~/booksrc $ gcc -g tinyweb.c 
  * reader@hacking:~/booksrc $ sudo gdb -q --pid=13019 --symbols=./a.out 
  * Using host libthread\_db library "/lib/tls/i686/cmov/libthread\_db.so.1". Attaching to process 13019 /cow/home/reader/booksrc/tinyweb: No such file or directory. A program is being debugged already. Kill it? \(y or n\) n Program not killed.

## Bash commands

```text
reader@hacking:~/booksrc $ $(perl -e 'print "uname";') 
Linux 
reader@hacking:~/booksrc $ una$(perl -e 'print "m";')e
Linux
```

* `seq` in bash
  * for i in $\(seq 1 3 10\)
* The nm command lists symbols in object files. This can be used to find addresses of various functions in a program

