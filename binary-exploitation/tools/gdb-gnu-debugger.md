# GDB - GNU Debugger

## Commands

* Press enter to redo last command
* Launch gdb with `gdb [exe]`

### General

| Command | Effect |
| :--- | :--- |
| `file <exe>` | Load binary to debug |
| `show environment` |  |
| `set environment <ENV_NAME> <value>` | Set an env var \(don't use "\) |
| `show args` |  |
| `set args <value>` | Set arguments \(don't use "\) |
| `<disass | disassemble> <func>` | Show assembler code of function |
| `p | print <function>` | Prints the address of the function \(if it exist/is loaded within the program\) |
| `quit` |  |

### Move

| Short command | Long command | Effect |
| :--- | :--- | :--- |
| `r` | `run` | Run until next breakpoint |
| `c` | `continue` | Continue running until next breakpoint |
| `si` |  | Single step forward |

### Info

* `info functions` List available functions of the binary
* `info registers` Shows current registers value
* `info breakpoints` Shows breakpoints
* `info proc map` Shows what is loaded where in memory

### Breakpoints

* `del [breakpoint_nb]` Del all or a specific breakpoint
* `<b | break> <*address | *function_name>`
  * For functions `*` tells gdb to break at the first instruction \(without it, it would break after the function prologue\)
  * For addresses, it doesn't seem to work without it
  * You can also do `*<function+offset>`
* `define hook-stop` Define action to do on each breakpoints
  * Type one action per line \(for example `info registers` or `x/24wx $esp`
  * Write `end` to close the definition
  * To change it, use again the cmd

### Examine memory

* `x/[nb][format][size] [address]` Examine _nb_ data of _size_ & display it in given _format_ 
  * Format & size are interchangeable
  * Default : 
    * Nb : 1
    * Format & size : Last used
    * Address : Last thing printed with this command or `print`
  * Address can also be a register \(like `$esp`\)
  * Available format :
    * `o` Octal
    * `x` Hex
    * `d` Decimal
    * `u` Unsigned decimal
    * `t` Binary
    * `f` Float
    * `a` Address
    * `i` Instruction
    * `c` Char
    * `s` String
  * Available size :
    * `b` Byte
    * `h` Half word
    * `w` Word
    * `g` Giant \(8 bits\)

### Find string in memory

* You might need the address of a specific string \(to use in a payload for example\)
* There's 2 way to do that :
  * Run : `find <start_address | function_name>, +<offset>, <your_string>`
    * It will search for it from the start address \(/ address of the function\) to the offset
    * Don't hesitate to use a big offset like 9999999
  * If the string exist within a lib that will be loaded, use \(outside of gdb\) : `strings -t x <lib_name.so> | grep <your_string>` 
    * It will return the offset of your string within the file
    * Then : load a binary in gdb that uses the lib, retrieve the base address of this lib in memory \(with `info proc map`\), and add the offset
* Check that you've got the right string with with `x/s <final_address>`

## Sources

* LiveOverlfow's [Binary Exploitation](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) series
* Man pages

