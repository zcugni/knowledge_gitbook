# GDB - GNU Debugger

## Generalities

* Lets you debug and disassemble code from multiple languages
* Standard on unix machine
* Init file : `~/.gdbinit`
  * Write config lines to it, like `set disassembly intel`

{% hint style="info" %}
Test if you can define hook-stop there too
{% endhint %}

## Commands

* Press enter to redo last command
* Launch gdb with `gdb [exe]`
* Registers can be access via `$<name>` : `$eip`

### General

| Command | Effect |
| :--- | :--- |
| `file <exe>` | Load binary to debug |
| `show environment` |  |
| `set environment <ENV_NAME> <value>` | Set an env var \(don't use "\) |
| `show args` |  |
| `set args <value>` | Set arguments \(don't use "\) |
| `<disass | disassemble> <func>` | Show assembler code of function |
| `p | print ...` | Will print info on what you ask, it can be functions, registers, etc. The info will depend on the type of data |
| `quit` |  |
| `bt` | Shows stack trace where you stopped \(all function calls\) |
| `bt full` | Shows stack trace where you stopped \(all function calls + their local variable\) |
| `<set disassembly | set disassembly-flavor> <intel | att>` | Define which syntax to use for disassembled code \(intel or att\), default is att |
|  `follow-fork-mode child` | Follow the child process after a call |

### Move

| Short command | Long command | Effect |
| :--- | :--- | :--- |
| `r` | `run` | Run until next breakpoint |
| `c` | `continue` | Continue running until next breakpoint |
| `si` |  | Single step forward |

### Info

* `<i | info> ...`
* The dots can be replace by : 
  * `functions | f` List available functions of the binary
  * `registers | r` Shows current registers value
  * `breakpoints | b` Shows breakpoints
  * `proc map` Shows what is loaded where in memory

### Breakpoints

* `del [breakpoint_nb]` Del all or a specific breakpoint
* `<b | break> <*address | *function_name>`
  * For functions `*` tells gdb to break at the first instruction \(without it, it would break after the function prologue\)
  * For addresses, it doesn't seem to work without it
  * You can also do `*<function+offset>`
* `define hook-stop` Define action to do on each breakpoints
  * Type one action per line \(for example `info registers` or `x/24wx $esp`
  * Write `end` to close the definition
  * To change it, use again the cmd

### Examine memory

* `x/[nb][format][size] [address]` Examine _nb_ data of _size_ & display it in given _format_ 
  * Format & size are interchangeable
  * Default : 
    * Nb : 1
    * Format & size : Last used
    * Address : Last thing printed with this command or `print`
  * Address can also be a register \(like `$esp`\)
  * Available format :
    * `x` Hex
    * `d` Decimal
    * `a` Address
    * `i` Instruction 
    * `c` Char
    * `s` String
    * `t` Binary
    * `o` Octal
    * `u` Unsigned decimal
    * `f` Float
  * Available size :
    * `b` Byte
    * `h` Half word \(2 bytes\)
    * `w` Word \(4 bytes\)
    * `g` Giant \(8 bytes\)

### Find string in memory

* You might need the address of a specific string \(to use in a payload for example\)
* There's 2 way to do that :
  * Run : `find <start_address | function_name>, +<offset>, <your_string>`
    * It will search for it from the start address \(/ address of the function\) to the offset
    * Don't hesitate to use a big offset like 9999999
  * If the string exist within a lib that will be loaded, use \(outside of gdb\) : `strings -t x <lib_name.so> | grep <your_string>` 
    * It will return the offset of your string within the file
    * Then : load a binary in gdb that uses the lib, retrieve the base address of this lib in memory \(with `info proc map`\), and add the offset
* Check that you've got the right string with with `x/s <final_address>`

## Debug option

* If the C source code was compiled with `gcc` and the  `-g` options \(for extra debugging\), `gdb` can has access to more commands :
  * `List [func_name | line_nb]` Will show a function **source code** or 10 lines from the given line
    * Used without parameters, it will show the next 10 lines following the previous listing or from the start of the file if there wasn't one
    * You can also set breakpoints using line numbers shown with `list`
  * You can also print variable `print <var_name`
    * And there addresses `print &<var_name>`

## Sources

* LiveOverflow's [Binary Exploitation](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) series
* Hacking : The Art of Exploitation by John Erickson
* Man pages

