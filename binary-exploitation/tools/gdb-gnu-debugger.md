# GDB - GNU Debugger

## Draft

* `gdb <exe>`
* `file <exe>` Load bin to debug
* `info <...>` Gives info on what you ask, interesting things are :
  * `info functions` List available functions of the binary
  * `info registers` Shows current registers value
  * `info breakpoints` Shows breakpoints
* `x/[nb][format][size] [address]` Examine nb data of size & display it in format 
  * Format & size are interchangeable
  * Default : ``
    * Nb : 1
    * Format & size : last used
    * Address : Last thing printed with this command or `print`
  * Address can also be a register \(like `$esp`\)
  * Available format :
    * `o` Octal
    * `x` Hex
    * `d` Decimal
    * `u` Unsigned decimal
    * `t` Binary
    * `f` Float
    * `a` Address
    * `i` Instruction
    * `c` Char
    * `s` String
  * Available size :
    * `b` Byte
    * `h` Half word
    * `w` Word
    * `g` Giant \(8 bits\)
* `del [breakpoint_nb]` Del all or a specific breakpoint
* `<b | break> <line_number |` \*`function_name> .. +x`
  * For function `*` tells gdb to break at the first instruction \(without it, it would break after the function prologue\)
  * For addresses, it doesn't seem to work without it
* `r | run` Run until next breakpoint
* `c | Continue` Continue running until next breakpoint
* `<disass | disassemble> <func>`
* `define hook-stop` Define action to do on each breakpoints
* `quit`
* `set environment <ENV_NAME> <value>`
  * Don't use `"` for the value
* `show environment`
* `si` Single step
* press enter to redo last command

## Protostar exercice

* lea : copy the address
* mov : copy the value pointed by the address 
*   ```text
  python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
  ```

  * The `0xCC` opcode is used for **breakpoints**. It's the **interrupt 3** and it's a trap to debugger, meaning that when it is raised, control is pass to the debugger
  * The `0x90` opcode is the **nop** instruction, which is a filler instruction.

## Nop Slide

* Given 2 terminal windows in which we run the same program, the stack pointer at the same instruction might not point to the same address
  * This is because some env var \(like `PWD`\) and other differences between the two terms might be push to the stack when you run the program
  * If they don't have the same value, when we arrive at our instruction, it might not be at the same place
* This can be problematic when writing shellcode, so we use nop slide
  * Simply write a looooot of nop instruction \(that does nothing\) and give an offset somewhere plausible
  * You'll probably land in your nop slide, and you can ride it until you arrive at the specific instruction you needed
* To summarize : it increase the range of possible instructions addresses that will direct the program to your code 

## Shellcode

* Pre-written assembly shellcode \(aka, assembly that corresponds to shell cmd, like launching /bin/bash`)` are available at shell-storm



* Given a shellcode that launches `/bin/bash`, if you do your exploit like this : `python generate_input.py | vuln_bin` , you'll get a problem
  * Bash needs an stdin, however, when your scripts finished outputting the initial payload, it will close the pipe
  * To keep it open, use `cat` with it : `(python generate_input.py ; cat) | vuln_bin`
    * When used without parameters, cat redirects `stdin` to `stdout` \(or here, the stdin of the new bash\) 

