# GDB - GNU Debugger

## Commands

Press enter to redo last command

### General

| Command | Effect |
| :--- | :--- |
| `gdb <exe>` | Launch gdb on exe |
| `file <exe>` | Load binary to debug |
| `show environment` |  |
| `set environment <ENV_NAME> <value>` | Set an env var \(don't use "\) |
| `<disass | disassemble> <func>` | Show assembler code of function |
| `p | print <function>` | Prints the address of the function \(if it exist/is loaded within the program\) |
| `quit` |  |

### Move

| Short command | Long command | Effect |
| :--- | :--- | :--- |
| `r` | `run` | Run until next breakpoint |
| `c` | `continue` | Continue running until next breakpoint |
| `si` |  | Single step forward |

### Info

* `info functions` List available functions of the binary
* `info registers` Shows current registers value
* `info breakpoints` Shows breakpoints
* `info proc map` Shows what is loaded where in memory

### Breakpoints

* `del [breakpoint_nb]` Del all or a specific breakpoint
* `<b | break> <address | *<function_name>`
  * For functions `*` tells gdb to break at the first instruction \(without it, it would break after the function prologue\)
  * For addresses, it doesn't seem to work without it
  * You can also do `*<function+offset>`
* `define hook-stop` Define action to do on each breakpoints
  * Type one action per line \(for example `info registers` or `x/24wx $esp`
  * Write `end` to close the definition

### Examine memory

* `x/[nb][format][size] [address]` Examine _nb_ data of _size_ & display it in given _format_ 
  * Format & size are interchangeable
  * Default : ``
    * Nb : 1
    * Format & size : Last used
    * Address : Last thing printed with this command or `print`
  * Address can also be a register \(like `$esp`\)
  * Available format :
    * `o` Octal
    * `x` Hex
    * `d` Decimal
    * `u` Unsigned decimal
    * `t` Binary
    * `f` Float
    * `a` Address
    * `i` Instruction
    * `c` Char
    * `s` String
  * Available size :
    * `b` Byte
    * `h` Half word
    * `w` Word
    * `g` Giant \(8 bits\)

### Find string in memory

* You might need the address of a specific string \(to use in a payload for example\)
* There's 2 way to do that :
  * Run : `find <start_address | function_name>, +<offset>, <your_string>`
    * It will search for it from the start address \(/ address of the function\) to the offset
    * Don't hesitate to use a big offset like 9999999
  * If the string exist within a lib that will be loaded, use \(outside of gdb\) : `strings -t x <lib_name.so> | grep <your_string>` 
    * It will return the offset of your string within the file
    * Then load a binary in gdb that uses the lib, retrieve the base address of this lib in memory \(with `info proc map`\), and add the offset
* Check that you're write with `x/s <address>`

## Protostar exercice

* lea : copy the address
* mov : copy the value pointed by the address 
*   ```text
  python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
  ```

  * The `0xCC` opcode is used for **breakpoints**. It's the **interrupt 3** and it's a trap to debugger, meaning that when it is raised, control is pass to the debugger
  * The `0x90` opcode is the **nop** instruction, which is a filler instruction.

## Nop Slide

* Given 2 terminal windows in which we run the same program, the stack pointer at the same instruction might not point to the same address
  * This is because some env var \(like `PWD`\) and other differences between the two terms might be push to the stack when you run the program
  * If they don't have the same value, when we arrive at our instruction, it might not be at the same place
* This can be problematic when writing shellcode, so we use nop slide
  * Simply write a looooot of nop instruction \(that does nothing\) and give an offset somewhere plausible
  * You'll probably land in your nop slide, and you can ride it until you arrive at the specific instruction you needed
* To summarize : it increase the range of possible instructions addresses that will direct the program to your code 

## Shellcode

* Pre-written assembly shellcode \(aka, assembly that corresponds to shell cmd, like launching /bin/bash`)` are available at shell-storm



* Given a shellcode that launches `/bin/bash`, if you do your exploit like this : `python generate_input.py | vuln_bin` , you'll get a problem
  * Bash needs an stdin, however, when your scripts finished outputting the initial payload, it will close the pipe
  * To keep it open, use `cat` with it : `(python generate_input.py ; cat) | vuln_bin`
    * When used without parameters, cat redirects `stdin` to `stdout` \(or here, the stdin of the new bash\) 

## Return oriented-programming / ret2libc

* Some programs implement protection to prevent buffer overflow from being usable, like :
  * Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
  * Make the stack writable only, not executable
* To bypass that, there's different options :
  * Change the return address to itself \(so to the address of the ret call\), so that it will pop itself from the stack and then \(since a ret call is made again\), set the `ip` to the next address on the stack \(which we control\)
  * Return to a function within the libc \(which is probably loaded for the program\) by crafting the stack as if a ret call was made. You'll need to write to the stack :
    * The address of the function you want to use
    * An address for this function to return to after if finishes
    * It's argument
      * If they're strings, you'll need to find in memory a place where the string is written and give it's address
    * This principle is called **ret2libc**
* Both technique can be chained multiple times

## Sources

* * LiveOverlfow Binary Exploitation series

\`\`

