# GDB - GNU Debugger

## Generalities

* Lets you debug and disassemble code from multiple languages
* Standard on unix machine
* Config file : `~/.gdbinit`
  * One config per line
  * Some useful : 
    * `set disassembly <intel | att>` Set the syntax
    * `set pagination off` Removes the warning & pause when printing something too long

## Commands

* Press enter to redo last command
* Launch gdb with `gdb [exe]`
  * If you want to directly specify the arguments : `gdb --args <exe> <arg1> ..`
* Registers can be access via `$<name>` : `$eip`

### Hooks

* Hooks are action to do before or after a certain event
* You can define hook for different situation :
  * `define hook-<cmd>` Will be run before the command each time it's called
  * `define hookpost-<cmd>` Will be run just after the command each time it's called
  * `define hook-stop` Will be run each time execution stops \(like with breakpoints\)
    * My go to hook is :

```text
define hook-stop
>i r
>x/24wx $esp
></2i $eip
>end
```

### Set

* `set <disassembly | disassembly-flavor> <intel | att>`
  * Define which syntax to use for disassembled code \(intel or att\), default is att
* `set environment <ENV_NAME> <value>`
* `set args <value>`
* `set {int}0x... = 0x..` Lets you rewrite an address
* For value, don't use `"`

### General

| Command | Effect |
| :--- | :--- |
| `file <exe>` | Load binary to debug |
| `attach <PID>` | Attach gdb to a running process |
| `show environment` |  |
| `show args`  |  |
| `<disass | disassemble> <func>` | Show assembler code of function |
| `p | print ...` | Will print info on what you ask, it can be functions, registers, etc. The info will depend on the type of data |
| `quit` |  |
| `bt` | Shows stack trace where you stopped \(all function calls\) |
| `bt full` | Shows stack trace where you stopped \(all function calls + their local variable\) |
|  `follow-fork-mode child` | Follow the child process after a call |

### Move

| Short command | Long command | Effect |
| :--- | :--- | :--- |
| `r [arg1] [arg2] [...]` | `run [arg1] [arg2] [...]` | Run until next breakpoint |
| `c` | `continue` | Continue running until next breakpoint |
| `si` |  | Single step forward |

* If you want to take the input from a file, you can do `r < /path/to/file`

### Info

* `<i | info> ...`
* The dots can be replaced by : 
  * `functions | f` List available functions of the binary
  * `registers | r` Shows current registers value
  * `breakpoints | b` Shows breakpoints
  * `proc map` Shows what is loaded where in memory

### Breakpoints

* `del [breakpoint_nb]` Del all or a specific breakpoint
* `<b | break> <*address | *function_name>`
  * For functions `*` tells gdb to break at the first instruction \(without it, it would break after the function prologue\)
  * For addresses, it doesn't seem to work without it
  * You can also do `*<function+offset>`

### Examine memory

* `x/[nb][format][size] [address]` Examine _nb_ data of _size_ & display it in given _format_ 
  * Format & size are interchangeable
  * Default : 
    * Nb : 1
    * Format & size : Last used
    * Address : Last thing printed with this command or `print`
  * Address can also be a register \(like `$esp`\)
  * Available format :
    * `x` Hex
    * `d` Decimal
    * `a` Address
    * `i` Instruction 
    * `c` Char
    * `s` String
    * `t` Binary
    * `o` Octal
    * `u` Unsigned decimal
    * `f` Float
  * Available size :
    * `b` Byte
    * `h` Half word \(2 bytes\)
    * `w` Word \(4 bytes\)
    * `g` Giant \(8 bytes\)

### Find string in memory

* You might need the address of a specific string \(to use in a payload for example\)
* There's 2 way to do that :
  * Run : `find <start_address | function_name>, +<offset>, <your_string>`
    * It will search for it from the start address \(/ address of the function\) to the offset
    * Don't hesitate to use a big offset like 9999999
  * If the string exist within a lib that will be loaded, use \(outside of gdb\) : `strings -t x <lib_name.so> | grep <your_string>` 
    * It will return the offset of your string within the file
    * Then : load a binary in gdb that uses the lib, retrieve the base address of this lib in memory \(with `info proc map`\), and add the offset
* Check that you've got the right string with with `x/s <final_address>`

## Debug option

* If the C source code was compiled with `gcc` and the  `-g` options \(for extra debugging\), `gdb` can has access to more commands :
  * `list [func_name | line_nb]` Will show a function **source code** or 10 lines from the given line
    * Used without parameters, it will show the next 10 lines following the previous listing or from the start of the file if there wasn't one
    * You can also set breakpoints using line numbers shown with `list`
  * You can also print variable `print <var_name`
    * And there addresses `print &<var_name>`

## Sources

* LiveOverflow's [Binary Exploitation](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) series
* _Hacking : The Art of Exploitation_ by John Erickson
* Man pages

