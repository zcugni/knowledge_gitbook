# Vulnerabilities

## Buffer Overflows

* They work by overflowing the local variable so that they write over the **return address**
* This enables us to decide which instruction will be read next
* Remark : The local variables are at lower addresses than the return address. Since array grow towards higher addresses, it's possible to override the return address.

## Shellcode

* Crafted malicious string that lets you run command or other instructions, this is usually where you want to redirect the flow of the program once you control it
* Pre-written assembly shellcode \(aka, assembly that corresponds to shell cmd, like launching `/bin/bash`\) are available at [shell-storm](http://shell-storm.org/shellcode/)

## Nop Slide

* Given 2 terminal windows in which we run the same program, the stack pointer at the same instruction might not point to the same address
  * This is because some env var \(like `PWD`\) and other differences between the two terms might be pushed to the stack when you run the program
  * If they don't have the same value, when we arrive at our instruction, it might not be at the same address
* This can be problematic when writing shellcode, so we use nop slide
  * A nop instruction does nothing, it's just a filler \(opcode `0x90`\)
  * Simply write many nop instructions and redirect the program to a plausible offset
  * You'll probably land in your nop slide, and you can ride it until you arrive at the specific instruction you needed
* To summarize : it increase the range of possible addresses that will direct the program to your code 

## Return oriented-programming / ret2libc

* Some programs implement protection to prevent buffer overflow from being usable, like :
  * Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
  * Making the stack writable only, not executable
* To bypass that, there's different options :
  * Change the return address to itself \(so to the address of the ret call\)
    * It will pop itself from the stack and then \(since a ret call is made again\), set the `ip` to the next address on the stack \(which we control\)
  * Return to a function within the libc \(which is probably loaded for the program\) by crafting the stack as if a ret call was made. You'll need to write to the stack :
    * The address of the function you want to use
    * An address for this function to return to after it finishes
    * Its arguments \(if they're strings, you'll need to [find in memory](https://zcugni.gitbook.io/notes/binary-exploitation/tools/gdb-gnu-debugger#find-string-in-memory) a place where the string is written and give its address\)
    * This principle is called **ret2libc**
* Both technique can be chained multiple times

## Format string vulnerabilities

* Whenever a format function is used \(like `printf`\), we can abuse it **if we control the format part**
* For each specifier, printf will read the memory at the current stack pointer and interpret it according to the specifier
* It has a variable number of arguments, so it blindly follows the specifiers
  * If we provide more than there's parameters, it will read the stack
* `%x` Can be used to read the stack in hexadecimal
* `%s` Can be used to :
  * **Crash the program**. It'll try to interpret any data as a memory address, so it might get a non-existent one, or one in protected space, and crash
  * **Read any memory location**. Since we control the format string, and it's pushed to the stack, we can insert an address in it and then use %s to read it : `printf(“\xef\xbe\xad\xde %x %x %x %s”, A, B, C);`
    * Will read the address at 0xdeadbeef
    * The `%x` are placeholders used to move the stack pointer to the format string \(since there's 3 parameters before it because of A, B & C\)
* `%n` Can be use to **write in any memory location**
  * It will write the number of characters written so far into the memory address pointed by it's variable
  * We can use the same trick as with `%s`, just replace it by `%n` in the above example to write at 0xdeadbeef
* Use **length modifiers** to write many chars with a few one \(for example `%64d` write 64 chars\)

## Generate inputs

```bash
# Different ways to generate input :
python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
python generate_input.py | /path/to/exe
# Necessary for shellcode that returns a shell or interactive stuff like it
(python generate_input.py; cat) | /path/to/exe

# If you need a parameter and not an input, do as follows :
./exe $(python -c "print 'your_hex'")
```

The 5th line is needed when dealing with shellcode that run `/bin/bash` or interactive stuff like that because they need an `stdin`.However, when your scripts finishes outputting the initial payload, it will close the pipe. When used without parameters, cat redirects `stdin` to `stdout`

## Tips & Tricks

* Don't forget that if some type of bits are sanitized, you can use registers to store values and do arithmetic operations
  * For example, you can move another value to a register, add or subtract from it so that it equals what you want, and push the register instead of directly the value

## Sources

* For buffer overflows :
  * [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
  * [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)
* For format strings :
  * [A pdf](http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf)
  * [medium](https://medium.com/swlh/binary-exploitation-format-string-vulnerabilities-70edd501c5be)

