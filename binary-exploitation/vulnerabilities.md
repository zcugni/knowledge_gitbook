# Vulnerabilities

## Buffer Overflows

* Buffer overflows let you overwrite memory by overflowing a buffer in which your input is written
  * This is only possible when the length of your input isn't checked
* The most common buffer overflows are stack related, they work by overflowing the local variable to write over the **return address**, enabling us to decide which instructions will be read next
  * If you're not sure of the distance between your input and the return address, just fill it with the crafted return address. At least one instance will overwrite what you want \(given that the stack is aligned\)
* When overflowing memory allocated on the heap, errors in the heap headers will be detected during  `free()`, and the program will stop
  * However, if you could do what you want before the free, it's not important

{% hint style="info" %}
* Check heap unlinking
* Since the write of the book, there's probably more mitigation, research that
{% endhint %}

## Shellcode

* Crafted malicious string that lets you run command or other instructions
* This is usually where you want to redirect the flow of the program once you control it
* Pre-written assembly shellcode \(aka, assembly that corresponds to shell cmd, like launching `/bin/bash`\) are available at [shell-storm](http://shell-storm.org/shellcode/)

## Nop Slide

* The stack won't be exactly the same on different environment \(even just on different terminals\), because executable names, env var, etc are pushed to the stack
* This makes guessing the exact address you want to redirect the program to difficult
* The 1-byte **nop** assembly instruction stands for "No operation", it's a filler instruction
  * When reading it, the program won't do anything and just advance to the next instruction
* To  increase the possible range of address that will redirect to your shell code, you can create a **nop slide**
  * This means writing a lot of nop instruction before your shellcode
  * You can then redirect the program anywhere in the slide and the program will "ride" it until your shellcode

## Return oriented-programming / ret2libc

* Some programs implement protection to prevent buffer overflow from being usable, like :
  * Checking that the return address is not pointing to somewhere within the stack \(and exiting without returning if it's the case\)
  * Making the stack writable only, not executable
* To bypass that, there's different options :
  * Change the return address to itself \(so to the address of the ret call\)
    * It will pop itself from the stack and then \(since a ret call is made again\), set the `ip` to the next address on the stack \(which we control\)
  * Return to a function within the libc \(which is probably loaded for the program\) by crafting the stack as if a ret call was made. You'll need to write to the stack :
    * The address of the function you want to use
    * An address for this function to return to after it finishes
    * Its arguments \(if they're strings, you'll need to [find in memory](https://zcugni.gitbook.io/notes/binary-exploitation/tools/gdb-gnu-debugger#find-string-in-memory) a place where the string is written and give its address\)
    * This principle is called **ret2libc**
* Both technique can be chained multiple times

## 

## Crafting inputs

### Python

* For simple exploits, you can craft your input using python and then send it to the vulnerable program
* Different ways to craft it :

```python
python -c 'print("\x61\x62\x63\x64")' | /path/to/exe
python generate_input.py | /path/to/exe
(python generate_input.py; cat) | /path/to/exe
```

* The last one is needed for shellcode that returns a shell because they need an `stdin`, however, when your script finishes outputting the input, it will close the pipe
  * Using `cat` without parameters redirects `stdin` to `stdout`, keeping the pipe open
* Send the payload as a **parameter** instead of an input :

```bash
./exe $(python -c "print 'your_hex'")
./exe "`python -c "print 'your_hex'"`"
```

### C

* For more complicated exploits, where you need to find specific memory addresses, etc, it might be easier to create a C binary that will launch the command with specifics parameters, making it possible to use C functions
* Be careful, a setuid program using `system()` won't transfer the privileges because they'll be drop by `/bin/bash`, prefer functions like `execle()`
* This is a \(truncated\) example from _Hacking : The Art of Exploitation_ that shows the kind of C program you would use for a stack buffer overflow :

```c
#include ...

char shellcode[]= "\x31\xc0\x31....";

int main(int argc, char *argv[]) {
  unsigned int i, ret;
  char *env[2] = {shellcode, 0};
  char *buffer = (char *) malloc(160);
  
  // Since we use a custom environment with execle
  // We can deduce the address of the shellcode  
  ret = 0xbffffffa - (sizeof(shellcode)-1) - strlen("./notesearch");
  
  // We write the wanted address multiple times
  // to be sure to overwrite the return address with it
  for(i=0; i < 160; i+=4)
    *((unsigned int *)(buffer+i)) = ret;
  
  // notesearch is the command to launch
  execle("./notesearch", "notesearch", buffer, 0, env);
  free(buffer);
}
```

## Tips & Tricks

* Don't forget that if some type of bits are sanitized, you can use registers to store values and do arithmetic operations
  * For example, you can move another value to a register, add or subtract from it so that it equals what you want, and push the register instead of directly the value

## Sources

* For buffer overflows :
  * [dhavalkapil.com](https://dhavalkapil.com/blogs/Buffer-Overflow-Exploit/)
  * [Stack overflow](https://security.stackexchange.com/questions/135786/if-the-stack-grows-downwards-how-can-a-buffer-overflow-overwrite-content-above)
* For format strings :
  * [A pdf](http://www.cis.syr.edu/~wedu/Teaching/cis643/LectureNotes_New/Format_String.pdf)
  * [medium](https://medium.com/swlh/binary-exploitation-format-string-vulnerabilities-70edd501c5be)

